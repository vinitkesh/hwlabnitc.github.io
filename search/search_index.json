{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Hardware Lab Guide This course covers the following topics- Introduction to Verilog and Single Cycle - Verilog is a hardware description language (HDL) used for designing and simulating digital systems. In this course, you will learn about Verilog in detail, including its syntax, data types, modules, behavioral modeling, and structural modeling. You will also understand how to simulate and test your Verilog designs and further run basic MIPS instructions using your own Single Cycle program. Introduction to MIPS ISA - MIPS (Microprocessor without Interlocked Pipeline Stages) is a reduced instruction set computer (RISC) architecture commonly used in embedded systems and educational environments. In this course, you will dive into the details of the MIPS architecture, including its instruction set, registers, memory organization, and execution flow. You will also learn how to write MIPS assembly code and understand the basic concepts of computer organization and architecture. Course Layout This tutorial is split into a 2 parts for each topic- \u2003\u2003 1. Theory - This part focuses on the theoretical concepts and principles of the topic. You will find comprehensive documentation and video explanation that covers the fundamental ideas, techniques, and best practices related to Verilog and MIPS. These resources will provide you with a solid understanding of the topics and their applications. \u2003\u2003 2. Implementation - This part emphasizes the practical aspect of the course. You will find documentation and video tutorials that guide you through the implementation of Verilog designs and MIPS assembly code. This hands-on approach will help you gain practical skills and experience in designing and working with digital systems using Verilog and MIPS. By following this course layout, you will have a well-rounded understanding of Verilog and MIPS, both from a theoretical and practical perspective.","title":"Home"},{"location":"#welcome-to-the-hardware-lab-guide","text":"This course covers the following topics-","title":"Welcome to the Hardware Lab Guide"},{"location":"#_1","text":"Introduction to Verilog and Single Cycle - Verilog is a hardware description language (HDL) used for designing and simulating digital systems. In this course, you will learn about Verilog in detail, including its syntax, data types, modules, behavioral modeling, and structural modeling. You will also understand how to simulate and test your Verilog designs and further run basic MIPS instructions using your own Single Cycle program. Introduction to MIPS ISA - MIPS (Microprocessor without Interlocked Pipeline Stages) is a reduced instruction set computer (RISC) architecture commonly used in embedded systems and educational environments. In this course, you will dive into the details of the MIPS architecture, including its instruction set, registers, memory organization, and execution flow. You will also learn how to write MIPS assembly code and understand the basic concepts of computer organization and architecture.","title":""},{"location":"#course-layout","text":"This tutorial is split into a 2 parts for each topic- \u2003\u2003 1. Theory - This part focuses on the theoretical concepts and principles of the topic. You will find comprehensive documentation and video explanation that covers the fundamental ideas, techniques, and best practices related to Verilog and MIPS. These resources will provide you with a solid understanding of the topics and their applications. \u2003\u2003 2. Implementation - This part emphasizes the practical aspect of the course. You will find documentation and video tutorials that guide you through the implementation of Verilog designs and MIPS assembly code. This hands-on approach will help you gain practical skills and experience in designing and working with digital systems using Verilog and MIPS. By following this course layout, you will have a well-rounded understanding of Verilog and MIPS, both from a theoretical and practical perspective.","title":"Course Layout"},{"location":"SingleCycle/","text":"Single Cycle Processor Table of Contents Sl No. Topic 0 All resources 1 Overview 2 Prerequisites 3 Theory- Control Unit 4 Theory- Datapath 5 Implementation 1.1 Top Level Module 1.2 Data Memory 1.3 Instruction Memory 1.4 Microprocessor Top Level 1.5 Controller 1.6 Main Decoder 1.7 ALU Decoder 1.8 Datapath 1.9 Register File 1.10 Other Functional Units 6 How to Run Instructions 7 Test Cases for Various Instructions 8 References 0. Resources \u2003 Theory : \u2003\u2003Documentation: Link to Main Documentation: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Control Unit Theory :simple-youtube: \u2003\u2003\u2003\u2003 2. Datapath Theory :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation) : \u2003\u2003\u2003\u2003 1. Code Modules 1 to 5 explained :simple-youtube: \u2003\u2003\u2003\u2003 2. Code Modules 6 to 10 explained :simple-youtube: \u2003\u2003\u2003\u2003 3. All Testbenches explained :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 3: Download Here 1. Overview Till now you have learned to design sequential and combinational logic, in this section you will learn how to create a single cycle processor, specifically the MIPS microprocessor. This section combines almost every concept covered so far. Abstraction of block diagrams and Verilog HDLis used to describe the arrangement of each component. We exploit regularity and modularity by reusing already created blocks such as ALUs, multiplexers and register files. The microarchitecture is partitioned into datapath and control units. The MIPS microprocessor datapath uses the register file, ALU, memory unit, and instruction decoder to execute instructions. The register file stores data and instructions, the ALU performs operations, the memory unit accesses and stores data, and the instruction decoder controls data flow. The control unit of a MIPS microprocessor generates control signals that direct the flow of data between components in the datapath, ensuring that instructions are executed correctly. It receives instructions from the decoder, directs data flow to the correct components, and controls instruction timing. Together, the datapath and control units work to execute instructions in the MIPS microprocessor. We will focus on the single-cycle implementation of a subset of MIPS instructions. Additionally, we will compare single-cycle, multicycle, and pipelined microarchitectures for the MIPS processor. 2. Prerequisites To create a Verilog MIPS single cycle processor, you should have a strong understanding of digital logic design, computer architecture, and Verilog programming. Some of the specific prerequisites include- Knowledge of digital logic design concepts, such as combinational and sequential circuits, logic gates, flip-flops, and registers and implementing these in Verilog HDL. Understanding of computer architecture principles, including datapath and control unit design, memory organisation, instruction decoding, and input/output interfaces. These are also covered once more in the \u201cTheory\u201d section of our module. Experience with Verilog programming, including the ability to write and understand Verilog code, testbenches, and simulation results. Ability to use simulation and synthesis tools, such as ModelSim, Quartus, to simulate and synthesise Verilog code. Knowledge of computer organisation and assembly language programming is also beneficial, as it provides context for understanding the MIPS single cycle processor and its operation. Additionally, it would be helpful if you were familiar with the MIPS instruction set architecture, including its various instruction formats, opcode values, and functionality. 3. Control Unit This section covers an implementation of our MIPS subset, which is created by adding a basic control function to the datapath discussed in the previous section. Support for load word (lw), store word (sw), branch equal (beq), and arithmetic-logical instructions like add, sub, AND, OR, and set on less than are all included in this version. It is implemented in 2 parts: the main control Unit and ALU Control Unit. Firstly we look at the instruction format. Instruction Format The 32 bit MIPS instruction can be broken down into the following parts fig 2 The op field, called the opcode, is always contained in bits 31:26. We will refer to this field as Op[5:0] by standard notation. The two registers to be read are always specified by the rs and rt fields, at positions 25:21 and 20:16 . This is true for the R-type instructions, branch equal, and store. The base register for load and store instructions is always in bit positions 25:21 (rs). The 16-bit offset for branch equal, load, and store is always in positions 15:0 . The destination register is in one of two places. For a load, it is in bit positions 20:16 (rt), while for an R-type instruction it is in bit positions 15:11 (rd). Thus, we will need to add a multiplexor to select which field of the instruction is used to indicate the register number to be written. Main Control Unit (Main Decoder) The control unit computes the control ignals based on the opcode and funct fields of the instruction, [31:26] and [5:0] . Most of the control information comes from the opcode, but R-type instructions also use the funct field to determine the ALU operation. The majority of the outputs from the opcode are computed by the main decoder. The 6 bits of the opcode are decoded into various control signals of the Main Decoder as shown in Fig. 3. Fig 3. Simple PLA Implementation Table 1 explains each of the control signals in detail with all the important information. These nine control (two from ALUOp which are explained later) signals are set on the basis of six input signals to the control unit, which are the opcode bits 31 to 26. Control Signals Deasserted Asserted RegDst The write register number comes from the rt field (20:16) The write register number comes from the rd field (15:11) RegWrite - The register on the write register input is written with the value of the Write data input. ALUSrc Second ALU Operand is the second register file output. Second ALU Operand is the sign extended offset (16 bit to 32 bits) PCSrc PC = PC + 4 (For sequential exec.) PC is replaced by branch target. MemRead - Data memory contents designated by address input are put in Read Data Output. MemWrite - Data memory contents designated by address input are put in Write Data Output. MemtoReg Write Data is fed input from ALU. Write Data is fed input from Data Memory. Table 1. Different Control Signals for the different MUXs With the exception of the PCSrc control line, the control unit can set all of the control signals based only on the opcode field of the instruction. If the instruction is branch on equal and the ALU's Zero output is asserted, then the PCSrc control line should also be asserted. We must AND the Zero signal from the ALU with the Branch signal from the control unit in order to produce the PCSrc signal. ALU Control Unit (ALU Decoder) Depending on the instruction class, the ALU will need to perform one of these functions. Table 2. ALU Control Lines The main decoder determines a 2-bit ALUOp signal which is used as input for ALU Decoder along with the 6-bit funct (or function) field in the low-order bits of the instruction. The 4 bit output signal of the ALU Control Unit represents the operation to be carried out by the ALU. Fig 4. ALU Hardware Implementation The 2 bit ALUOp sent by the Control Unit indicates whether the operation to be performed should be add (00) for loads and stores, subtract (01) for beq, or determined by the operation encoded in the funct field (10). Understanding the optimal implementation: Using multiple levels of control can reduce the size of the main control unit. Using several smaller control units may also potentially increase the speed of the control unit. Such optimizations are important, since the speed of the control unit is often critical to clock cycle time ALU Control Truth Table Input-Output Truth Table 4. Datapath A datapath is the part of a computer processor that performs arithmetic and logic operations on data. It is a digital circuit that consists of registers , an arithmetic logic unit (ALU), and multiplexers . The datapath receives instructions and data from the processor's memory and performs the necessary operations specified by the instructions. The ALU performs arithmetic and logical operations on the data, and the registers store intermediate and final results. The datapath also includes multiplexers that allow the selection of different input values based on control signals. The control signals are generated by the control unit, which coordinates the operations of the datapath to execute instructions. The datapath operates on words of data. MIPS is a 32-bit architecture , so we will use a 32-bit datapath. The datapath first decodes the instruction for the control unit which then sets the different multiplexers thereby fixing the datapath. We will split the datapath into different state elements and try to learn them one by one and finally piece them together to create a complete datapath. State elements There are 5 main state elements required for building the datapath. a Instruction Memory The program counter contains the address of the instruction to be executed. The first step is to read this instruction from the element called instruction memory. The instruction memory takes the address in PC as the input and fetches the 32 bit instruction, labelled instr. The processor\u2019s actions depend on the specific instruction that was fetched. b Register File The register file contains all the available registers. It has two read ports and one write port. Since MIPS architecture contains 32 registers, each register is identified by a unique 5 bit number (log2 32). This unique 5 bit number is given as the input in both read and write ports. The contents of the registers specified via the read ports are given as the output. If the control signal RegWrite is set, the data given in the data port is written into the register given in the write port. c) ALU ALU performs different arithmetic operations on the data depending on the signal received from the control unit. It has two data input ports and an input from the control unit which specifies the operation to be performed. The final result is output through ALU result and zero port is set to 1 if the result is zero. d Data Memory The memory unit is a state element with inputs for the address and the write data, and a single output for the read result.There are separate read and write controls, called MemRead and MemWrite. Only one of these may be asserted at a time. If MemRead is set then value at the address given is fetched and outputted through the read data port. If MemWrite is set then the value at the address is changed to write data. e) Sign extension To understand what sign extension is, let\u2019s take an example. Consider the 4 bit number 1100. If we were to sign extend it to an 8 bit number, we take the MSB which in this case is 1 and extend it to make the upper half of the 8 bit number keeping the lower same as the initial 4 bits which gives us 1111 1100. Similarly, this element sign extends a 16 bit number into a 32 bit number. Now that we have seen the different state elements involved in a datapath, let's see the datapath followed by different MIPS instructions. Since we are considering MIPS microprocessor, each instruction is 32 bits long. add It is an R-type instruction of the form add $rd,$rs,$rt The R-type instruction format is The datapath for add instruction is as follows : Grab the instruction address from the PC. Decode instruction. Pass rs,rt and rd into read register and write register ports. Retrieve data from read register 1 and register 2 (rs and rt). Pass contents of rs and rt into the ALU as operands for the addition operation. The only difference between different arithmetic operations is in the ALU operation performed. Return back the ALU result to the register file as the Write data argument. The data will be written into the Write register specified by the rd field. Increment the value of PC to PC+4 to move on to the next instruction. lw(load word) The lw instruction is of the form lw $rt immediate($rs) . It has an I-type instruction format. The load word instruction copies the data stored at the address \u2018immediate+value(rs)\u2019 and stores it into the register rt. The datapath for lw instruction is as follows :- The instruction memory reads the PC and outputs the instruction. The control unit examines the most significant five bits of the instruction to determine the necessary datapath configuration. The register file receives the two register numbers rs and rt, with rs connected to the read port and rt to the write port. Read data 1 port outputs the data stored in rs. This output is then added to the sign-extended immediate using ALU. The ALU result is sent to the data memory unit, which reads the data stored at the address specified by the ALU result. Finally, the data read from the memory is returned to the register file, which writes it into register rt. PC is incremented to PC+4. sw(store word) sw instruction is of the form v sw $rt immediate($rs) The instruction format is again of the form I-type with an opcode 43. The store word instruction writes the data stored in the register rt into the memory address \u2018value(rs)+immediate \u2019. The datapath for sw instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five bits and determines the necessary datapath configuration by setting the multiplexers. The register file receives two register numbers rs and rt, with rs connected to read port1 and rt connected to read port2. The data stored in registers rs and rt is output through the read data port1 and read data port2 respectively. The read data1 is then added to the sign-extended immediate using ALU. The ALU result along with read data2 (which contains the value stored in register rt) is sent to the data memory unit, which writes the read data2 into the address specified by the ALU result. PC is incremented to PC+4. beq (branch if equal) The beq instruction is of the form beq $rs ,$rt ,immediate It has an I-type instruction format. It compares the contents of rs and rt to check if they are equal and uses the 16-bit immediate field to compute the target address of the branch relative to the current address. The datapath for beq instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five its and determines the necessary datapath configuration. The register file receives two register numbers rs and rt in the read register port and outputs the contents in rs and rt. ALU subtracts the value of rs from rt and sets the zero port to 1 if the result is 0. The immediate value is sign extended and then shifted left by 2 bits. PC is incremented to PC+4 and is added with the immediate value to give the branch target. PC is changed to the branch target if zero port was set to 1. j (jump) The jump instruction is of the form j targaddr. It has a J-type instruction format with opcode 2. This instruction uses the 26 bit targaddr to compute jump address and updates the value of PC to jump address. The datapath for j instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five bits and determines the necessary datapath configuration. The 26 bit targaddr is shifted left by 2 bits to create a 28 bit result Concatenate the result with the upper 4 bits of PC+4 to get the jump address. Finally, the PC gets updated to the jump address. The Final Datapath Fig 4. Simple datapath with control unit (for R-type and I-type) Here, the input to the control unit is the 6-bit opcode field from the instruction. The outputs are the control signals which serve various purposes :- RegDst , ALUSrc , MemtoReg - 1-bit signals that control the multiplexors. RegWrite , MemRead , MemWrite - Signals that control reads and writes in the data memory and register file. Branch - Signal used in checking if a branch is required. ALUOp - 2-bit control signal for the ALU. Note that here, the AND gate is used to combine the Branch control signal with the Zero output from the ALU. This is responsible for the selection of the next PC. Role of Multiplexors As seen above, there are 4 multiplexors required at various stages of the datapath. They are needed in order to implement both R-type and I-type instructions using the same datapath. Their roles are explained below :- MUX 1 - This MUX determines which register needs to be written into using the RegDst control signal. If it\u2019s 0, the write register number comes from the rt field (in the case of I-type), whereas if it\u2019s 1, the write register number comes from the rd field (for R-type instructions) MUX 2 - This MUX is placed at the ALU input with ALUSrc as the select line. When it\u2019s 0, an arithmetic-logical instruction is taking place, and the second ALU operand is the data read from the second register. When it\u2019s 1, a memory instruction is taking place, with the second ALU operand being the sign-extended 16-bit immediate field from instruction. MUX 3 - It chooses which value is stored in the destination register using the MemtoReg control signal. This value comes from the ALU (for an R-type instruction) or the memory (for a load). MUX 4 - The final MUX is used to select if the PC moves onto the sequentially following instruction address (PC + 4) or branches to a target address. The control signal that achieves this is the output of the AND gate which is 1 in case of a branch instruction and 0 otherwise. Fig 4. Datapath with Jump implementation Additionally to implement the Jump instruction in the same datapath, an additional MUX, controlled by the jump control signal, is used to determine whether to move to the jump target address or the next consequent instruction. This jump target is obtained by shifting the lower 26 bits of the jump instruction left 2 bits (ie. multiplying by 4) and then concatenating the upper 4 bits of PC + 4 as the high-order bits, thus yielding a 32-bit address. 5. Implementation 1. Top level module module top (input clk, reset, output [31:0] writedata, dataadr, output memwrite); wire [31:0] pc, instr, readdata; // instantiate processor and memories mips mips (clk, reset, pc, instr, memwrite, dataadr, writedata, readdata); imem imem (pc[7:2], instr); dmem dmem (clk, memwrite, dataadr, writedata,readdata); endmodule The top level module instantiates 3 sub modules mips , imem and dmem The mips module is the main processor that is responsible for executing instructions. The imem module is the instruction memory, which contains the program instructions. The dmem module is the data memory, which is used for load/store instructions. Here is a brief description of the input and output ports of the top module: Inputs clk - the clock signal used to synchronise the processor. reset - the reset signal used to initialise the processor. Outputs writedata - the data to be written to memory. dataadr - the memory address to access. memwrite - the control signal for writing to memory. pc - the program counter, which contains the memory address of the current instruction. instr - the current instruction being executed. readdata - the data read from memory. Overall, the top module provides the infrastructure to execute programs on the MIPS processor. It loads the program instructions from memory, executes them, and stores the results back into memory if necessary. RTL view of top level module 2. Data Memory module dmem (input clk, we, input [31:0] a, wd, output [31:0] rd); reg [31:0] RAM[63:0]; assign rd RAM[a[31:2]]; // word aligned always @ (posedge clk) if (we) RAM[a[31:2]] wd; endmodule dmem represents a random access memory (RAM) block that can store and retrieve 32-bit data values. Inputs- clk MemWrite we - control signal that determines whether to write data to memory. 32 bit memory address a 32 bit WriteData \u2018wd\u2019- data to be written to the location specified by a . Output- 32 bit ReadData rd - data read from memory location a . The dmem module contains a RAM that stores 64 words each of size 32 bits. When the we input is set to 1, the 32 bit data wd gets written into the memory location a at the positive edge of clk . 3. Instruction Memory module imem (input [5:0] a,output [31:0] rd); reg [31:0] RAM[63:0]; integer i; initial begin $readmemh (\"E:\\memfile.dat\",RAM); end assign rd = RAM[a]; // word aligned endmodule Input : 6 bit address a : This is generated by the mips module. Output : 32 bit instruction rd : The instructions are stored initially in a file called memfile.dat. This file gets loaded into the RAM array using the $readmemh system task. The $readmemh system task reads a memory file in HEX format and initialises the memory array with these values. The syntax is : $readmemh(\"hex_memory_file.mem\", memory_array,[start_address],[end_address]) (The start and end address arguments are optional) The imem module is a combinational logic block which is driven by the RAM array. The input address a is used to index into the RAM array to retrieve the instruction located at that address. The instruction is then assigned to rd . RTL view of Instruction Memory 4. MIPS module mips(input clk, reset, output [31:0] pc, input [31:0] instr, output memwrite, output [31:0] aluout, writedata, input [31:0] readdata); wire memtoreg, branch, alusrc, regdst, regwrite, jump; wire [2:0] alucontrol; controller c(instr[31:26], instr[5:0], zero, memtoreg, memwrite, pcsrc, alusrc, regdst, regwrite, jump, alucontrol); datapath dp(clk, reset, memtoreg, pcsrc,alusrc, regdst, regwrite, jump,alucontrol,zero, pc, instr,aluout, writedata, readdata); endmodule Inputs : clk reset instr - current instruction being executed. 32 bit readdata - data read from the memory. Outputs : 32 bit pc - current program counter. 32 bit aluout - result of ALU operation(i applicable). 32 bit writedata memwrite - control signal (discussed earlier). The mips module instantiates two other modules, controller and datapath , which work together to execute instructions. Both these modules are discussed in detail in the upcoming sections. Overall the mips module acts like a traffic signal, directing the flow of data and control signals between the datapath and controller modules to execute instructions and maintain the processor\u2019s state. RTL view of MIPS module 5. Controller module controller (input [5:0] op, funct, input zero, output memtoreg, memwrite, output pcsrc, alusrc, output regdst, regwrite, output jump, output [2:0] alucontrol); wire [1:0] aluop; wire branch; maindec md (op, memtoreg, memwrite, branch,alusrc, regdst, regwrite, jump,aluop); aludec ad (funct, aluop, alucontrol); assign pcsrc = branch & zero; endmodule Inputs- 6 bit Opcode 6 bit funct Zero bit (for PCSrc) Outputs- 7 control signals memtoreg memwrite pcsrc alusrc regdst regwrite jump 3 bit alu control Temporary Variables 2 bit AluOP Branch bit Working It acts as a top level module connecting the main decoder and alu decoder. It has some additional logic to make the PCSrc control signal by AND-ing the branch (intermediate) signal from the main decoder and the Zero from the ALU. RTL View of Main Controller 6. Main Decoder module maindec(input [5:0] op, output memtoreg, memwrite, output branch, alusrc, output regdst, regwrite, output jump, output [1:0] aluop); reg [8:0] controls; assign {regwrite, regdst, alusrc, branch, memwrite, memtoreg, jump, aluop} = controls; always @ (*) case(op) 6'b000000: controls <= 9'b110000010; //Rtype 6'b100011: controls <= 9'b101001000; //LW 6'b101011: controls <= 9'b001010000; //SW 6'b000100: controls <= 9'b000100001; //BEQ 6'b001000: controls <= 9'b101000000; //ADDI 6'b000010: controls <= 9'b000000100; //J default: controls <= 9'bxxxxxxxxx; //??? endcase endmodule Input : 6 Bit Opcode Outputs : memtoreg memwrite branch alusrc regdst regwrite jump (These 7 represent the 7 control signals which originate from the Control Unit and are explained in Theory section Table 1) 1. 2 Bit ALUOp Temporary Variables 9 bit register control - It represents all the control signals together for easier assignment during the case statement. Working It is the main decoder which sets the control signals to 1s and 0s according to the opcode instruction. It uses a switch-case statement to decide what control to set inside a \u201calways\u201d procedural block. Note: always@(*) blocks are used to describe Combinational Logic , or Logic Gates. * sets the sensitivity list of the \u201calways\u201d to any values that can have an impact on a value(s) determined by the always@(*) block. RTL View of Main Decoder 7. ALU Decoder module aludec (input [5:0] funct, input [1:0] aluop, output reg [2:0] alucontrol); always @ (*) case (aluop) 2'b00: alucontrol <= 3'b010; // add 2'b01: alucontrol <= 3'b110; // sub default: case(funct) // RTYPE 6'b100000: alucontrol <= 3'b010; // ADD 6'b100010: alucontrol <= 3'b110; // SUB 6'b100100: alucontrol <= 3'b000; // AND 6'b100101: alucontrol <= 3'b001; // OR 6'b101010: alucontrol <= 3'b111; // SLT default: alucontrol <= 3\u2019bxxx; // ??? endcase endcase endmodule ```` Inputs : 1. 16 bit ```funct``` (from 32 bit MIPS Instruction) 2. 2 bit ```ALUOp``` (coming from Main decoder) Output : 1. 3 bit ALU control Working It decides what function the ALU will carry out. It works with a nested switch-case statement. First it checks the ```ALUop``` 1. If ```ALUOp``` = 1 -> ALU has to perform addition. (lw,sw) 2. If ```ALUOp``` = 2 -> ALU has to perform subtraction. (beq) 3. If ```ALUOp``` = 3 -> It depends on the 6 bit funct which will ADD, SUB, AND, OR, SLT (R-type) ![aludec](./2024%20Single%20Cycle%20Images/singlecycle-0113.png) RTL View of ALU Decoder ## 8. Datapath ```v module datapath (input clk, reset, input memtoreg, pcsrc, input alusrc, regdst, input regwrite, jump, input [2:0] alucontrol, output zero, output [31:0] pc, input [31:0] instr, output [31:0] aluout, writedata, input [31:0] readdata); wire [4:0] writereg; wire [31:0] pcnext, pcnextbr, pcplus4, pcbranch; wire [31:0] signimm, signimmsh; wire [31:0] srca, srcb; wire [31:0] result; // next PC logic flopr #(32) pcreg(clk, reset, pcnext, pc); adder pcadd1 (pc, 32b100, pcplus4); sl2 immsh(signimm, signimmsh); adder pcadd2(pcplus4, signimmsh, pcbranch); mux2 #(32) pcbrmux(pcplus4, pcbranch, pcsrc,pcnextbr); mux2 #(32) pcmux(pcnextbr, {pcplus4[31:28], instr[25:0], 2b00},jump, pcnext); // register file logic regfile rf(clk, regwrite, instr[25:21],instr[20:16], writereg,result, srca, writedata); mux2 #(5) wrmux(instr[20:16], instr[15:11], regdst, writereg); mux2 #(32) resmux(aluout, readdata, memtoreg, result); signext se(instr[15:0], signimm); // ALU logic mux2 #(32) srcbmux(writedata, signimm, alusrc,srcb); alu alu(srca, srcb, alucontrol,aluout, zero); endmodule Inputs : clk reset (They are external inputs.) memwrite regwrite regdst alusrc memtoreg pcsrc jump (They are the control signals from the main decoder.) 32 bit instr - output of the instruction memory. 32 bit readdata - output of the data memory. 3 bit alucontrol - output of the alu decoder. Outputs : zero 32 bit pc 32 bit aluout 32 bit writedata Working : The datapath is separated into 3 sections:- next PC logic The pseudocode for this section is- { always@(poseedge clk && poseedge reset) pc=pcnext; pcplus4=pc+4; signimm=signextend to 32 bits instr[15:0] signimmsh=shift left 2 of signimmsh pcbranch=pcplus4+signimmsh jump address= {pcplus4[31:28],instr[25:0], 2b00} if(pcsrc==0) pcnextbr=pcplus4; else pcnextbr=pcbranch; if(jump==0) pcnext=pcnextbr; else pcnext=jump address; } register file logic The pseudocode for this section is- { if(regdst==0) writereg=instr[20:16]; else writereg=instr[15:11]; if(memtoreg==0) result=aluout; else result=readdata; in registerfile { read register1=instr[25,21]; read register2=instr[20:16]; write register=writereg; write data=result; } } ALU In this section the ALU performs operations on \u2018srca\u2019(output of register file) and \u2018srcb\u2019 (depends on control signal alusrc) depending on the value of \u2018alucontrol\u2019. RTL view of datapath 9. Three ported Register module regfile (input clk, input we3, input [4:0] ra1, ra2, wa3, input [31:0] wd3, output [31:0] rd1, rd2); reg [31:0] rf[31:0]; always @ (posedge clk) if (we3) rf[wa3] <= wd3; assign rd1 = (ra1 != 0) ? (rf[ra1]) : 0; assign rd2 = (ra2 != 0) ? (rf[ra2]): 0; endmodule Inputs : Clk signal for third port Read register 1 ra1 Read register 2 ra2 Write register wa3 Write data we3 Outputs : Read data 1 rd1 Read data 2 rd2 Temporary Variables : 32 element Array of 32 bit registers Working : Two ports read combinationally. Third port written on the rising edge of the clock. If any of the registers are \u20180\u2019 it is hardwired to be 0 value by default. RTL View of Register File 10. Some Other Functional Units These units were explained in previous modules. As such explanation and theory is not repeated and can be referred to from those modules. 1. ADDER MODULE module adder (input [31:0] a, b,output [31:0] y); assign y=a + b; endmodule 2. SHIFT LEFT BY 2 MODULE module sl2 (input [31:0] a, output [31:0] y); assign y = {a[29:01], 2'b00}; endmodule 3. SIGN EXTENSION MODULE module signext (input [15:0] a,output [31:0] y); assign y={{16{a[15]}}, a}; endmodule First 16 bits of 32 bit Y are assigned the value of A[15] thus extending A by 16 bits. 4. D FLIP FLOP MODULE (with variable width) module flopr # (parameter WIDTH = 8)(input clk, reset,input [WIDTH-1:0] d,output reg [WIDTH-1:0] q); always @ (posedge clk, posedge reset) if (reset) q<=0; else q <= d; endmodule 5. 2 WAY MUX MODULE (with variable width) module mux2 # (parameter WIDTH = 8)(input [WIDTH-1:0] d0, d1,input s,output [WIDTH-1:0] y); assign y = s ? d1 : d0; endmodule 6. 32 BIT ALU MODULE module alu(i_data_A, i_data_B, i_alu_control,o_result,o_zero_flag); input [31:0] i_data_A; // A operand input [31:0] i_data_B; // B operand output reg [31:0] o_result; // ALU result input [3:0] i_alu_control; // Control signal output wire o_zero_flag; // Zero flag assign o_zero_flag = ~|o_result; always @(*) begin // Start initialization: casex(i_alu_control) 4'b0010: // ADD begin o_result = i_data_A + i_data_B; end 4'b0110: // SUB begin o_result = i_data_A - i_data_B; end 4'b0000: // AND begin o_result = i_data_A & i_data_B; end 4'b0001: // OR begin o_result = i_data_A | i_data_B; end 4'b0111: // SLT begin o_result = i_data_A < i_data_B ? 32'h00000001: 32'h00000000; end 4'b0011://XOR begin o_result=i_data_A^i_data_B; end 4'b0100://NOR begin o_result=~(i_data_A | i_data_B); end default: begin o_result={32{1'bx}}; //x-state,(nor1,nor0) end endcase end endmodule 6. How to Run Instructions Great! Now we have our single cycle microprocessor ready but how do we run assembly code in it? The following steps explain that in detail. ( Since its a MIPS implementation of a 32 Bit Microprocessor we shall use MIPS code as the assembly code. ) Steps to run Write Down the MIPS code you want to execute. Your code should have an instance of the instruction you want to test. Make sure the set of instructions ends with a store word (sw) instruction. The output of this \u201cstore word\u201d should be dependent on the instruction to be tested. (This will be used for checking if the instruction is executed correctly or not.) Convert the MIPS Code into machine code with the help of an online convertor. Save the machine code as \u201cmemfile.dat\u201d in your preferred directory. Update the path (line 6) of \u201cmemfile.dat\u201d in the imem module (Instruction Memory) of your Verilog code to the absolute path of the memfile.dat Change the test bench to check the following dataaddr- should contain the address of the last store word (X) in the last line of our machine code in memfile.dat writedata- should contain the data being written in memory (Y) in the last store word instruction. So, in the testbench make the change : (dataadr === X & writedata === Y ) Save the module and compile your Verilog code. Run RTL Simulation. The transcript section should contain \u201cSimulation succeeded\u201d in the case of a correct implementation and matching dataaddr and writedata. Fig. Sample transcript output 7. Test cases for Various Instructions Now we will try to check if our microprocessor implements instructions properly. 1. add addi $2, $0, 450 //initialise $2 =450 addi $3, $0, 550 //initialise $3 =550 add $4, $2, $3 //$4=$2+$3 ,$4=450+550=1000 sw $4, 20($0) //write address 20 = 1000 Machine code 200201c2 20030226 00432020 ac040014 If the value at address location 20 is 1000,then the add instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 1000) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule 2. sub addi $2,$0, 550 //initialise $2 =550 addi $3,$0, 550 //initialise $3 =550 sub $4,$2, $3 //$4=$2+$3 , $4=550-550=0 sw $4, 50($0) //write address 50 = 0 Machine code : 20020226 20030226 00432022 ac040032 If the value at address location 50 is 0,then the sub instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end //check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 50 & writedata === 0) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule 3. sw addi $2,$0,25 //initialise $2 =25 sw $2, 30($0) //write address 30 = 25 Machine code : 20020019 ac02001e If the value at address location 30 is 25,the sw instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 30 & writedata === 25) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule 4. lw addi $2,$0,100 //initialise $2 =100 sw $2,30($0) //write address 30 = 100 lw $3,30($0) //$3=[30] = 100 sw $3,20($0) //write address 20 = 100 Machine code 20020064 ac02001e 8c03001e ac030014 If the value at address location 20 is 100, then lw instruction is working properly. The testbench to check the same is:\\ module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 100) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 30) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule 5. beq main: addi $2,$0,20 //initialise $2 =20 addi $3,$0,30 //initialise $3 =30 addi $5,$0,0 //initialise $5 =0 beq $5,$0,end //if val($5)==val($0) branch to \u2018end\u2019 add $5,$2,$3 //$5=$2+$3 end: sw $5, 20($0) //write address 20 = 0 Machine code: 20020014 2003001e 20050000 10a00002 00432820 ac050014 If the value at address location 20 is 0,then the beq instruction is executed properly. The testbench for the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut (clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 0) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule 8. References \"Computer Organization and Design: The Hardware/Software Interface\" by David Patterson and John Hennessy \u201cDigital design and Computer architecture\u201d by David Money Harris & Sarah L. Harris. \u201cDigital Logic and Computer Design \u201dby M. Morris Mano. \u201cVerilog HDL: A Guide to Digital Design and Synthesis \u201d by Samir Palnitkar.","title":"Single Cycle"},{"location":"SingleCycle/#single-cycle-processor","text":"","title":"Single Cycle Processor"},{"location":"SingleCycle/#table-of-contents","text":"Sl No. Topic 0 All resources 1 Overview 2 Prerequisites 3 Theory- Control Unit 4 Theory- Datapath 5 Implementation 1.1 Top Level Module 1.2 Data Memory 1.3 Instruction Memory 1.4 Microprocessor Top Level 1.5 Controller 1.6 Main Decoder 1.7 ALU Decoder 1.8 Datapath 1.9 Register File 1.10 Other Functional Units 6 How to Run Instructions 7 Test Cases for Various Instructions 8 References","title":"Table of Contents"},{"location":"SingleCycle/#0-resources","text":"Theory : \u2003\u2003Documentation: Link to Main Documentation: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Control Unit Theory :simple-youtube: \u2003\u2003\u2003\u2003 2. Datapath Theory :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation) : \u2003\u2003\u2003\u2003 1. Code Modules 1 to 5 explained :simple-youtube: \u2003\u2003\u2003\u2003 2. Code Modules 6 to 10 explained :simple-youtube: \u2003\u2003\u2003\u2003 3. All Testbenches explained :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 3: Download Here","title":"0. Resources"},{"location":"SingleCycle/#1-overview","text":"Till now you have learned to design sequential and combinational logic, in this section you will learn how to create a single cycle processor, specifically the MIPS microprocessor. This section combines almost every concept covered so far. Abstraction of block diagrams and Verilog HDLis used to describe the arrangement of each component. We exploit regularity and modularity by reusing already created blocks such as ALUs, multiplexers and register files. The microarchitecture is partitioned into datapath and control units. The MIPS microprocessor datapath uses the register file, ALU, memory unit, and instruction decoder to execute instructions. The register file stores data and instructions, the ALU performs operations, the memory unit accesses and stores data, and the instruction decoder controls data flow. The control unit of a MIPS microprocessor generates control signals that direct the flow of data between components in the datapath, ensuring that instructions are executed correctly. It receives instructions from the decoder, directs data flow to the correct components, and controls instruction timing. Together, the datapath and control units work to execute instructions in the MIPS microprocessor. We will focus on the single-cycle implementation of a subset of MIPS instructions. Additionally, we will compare single-cycle, multicycle, and pipelined microarchitectures for the MIPS processor.","title":"1. Overview"},{"location":"SingleCycle/#2-prerequisites","text":"To create a Verilog MIPS single cycle processor, you should have a strong understanding of digital logic design, computer architecture, and Verilog programming. Some of the specific prerequisites include- Knowledge of digital logic design concepts, such as combinational and sequential circuits, logic gates, flip-flops, and registers and implementing these in Verilog HDL. Understanding of computer architecture principles, including datapath and control unit design, memory organisation, instruction decoding, and input/output interfaces. These are also covered once more in the \u201cTheory\u201d section of our module. Experience with Verilog programming, including the ability to write and understand Verilog code, testbenches, and simulation results. Ability to use simulation and synthesis tools, such as ModelSim, Quartus, to simulate and synthesise Verilog code. Knowledge of computer organisation and assembly language programming is also beneficial, as it provides context for understanding the MIPS single cycle processor and its operation. Additionally, it would be helpful if you were familiar with the MIPS instruction set architecture, including its various instruction formats, opcode values, and functionality.","title":"2. Prerequisites"},{"location":"SingleCycle/#3-control-unit","text":"This section covers an implementation of our MIPS subset, which is created by adding a basic control function to the datapath discussed in the previous section. Support for load word (lw), store word (sw), branch equal (beq), and arithmetic-logical instructions like add, sub, AND, OR, and set on less than are all included in this version. It is implemented in 2 parts: the main control Unit and ALU Control Unit. Firstly we look at the instruction format.","title":"3. Control Unit"},{"location":"SingleCycle/#instruction-format","text":"The 32 bit MIPS instruction can be broken down into the following parts fig 2 The op field, called the opcode, is always contained in bits 31:26. We will refer to this field as Op[5:0] by standard notation. The two registers to be read are always specified by the rs and rt fields, at positions 25:21 and 20:16 . This is true for the R-type instructions, branch equal, and store. The base register for load and store instructions is always in bit positions 25:21 (rs). The 16-bit offset for branch equal, load, and store is always in positions 15:0 . The destination register is in one of two places. For a load, it is in bit positions 20:16 (rt), while for an R-type instruction it is in bit positions 15:11 (rd). Thus, we will need to add a multiplexor to select which field of the instruction is used to indicate the register number to be written.","title":"Instruction Format"},{"location":"SingleCycle/#main-control-unit-main-decoder","text":"The control unit computes the control ignals based on the opcode and funct fields of the instruction, [31:26] and [5:0] . Most of the control information comes from the opcode, but R-type instructions also use the funct field to determine the ALU operation. The majority of the outputs from the opcode are computed by the main decoder. The 6 bits of the opcode are decoded into various control signals of the Main Decoder as shown in Fig. 3. Fig 3. Simple PLA Implementation Table 1 explains each of the control signals in detail with all the important information. These nine control (two from ALUOp which are explained later) signals are set on the basis of six input signals to the control unit, which are the opcode bits 31 to 26. Control Signals Deasserted Asserted RegDst The write register number comes from the rt field (20:16) The write register number comes from the rd field (15:11) RegWrite - The register on the write register input is written with the value of the Write data input. ALUSrc Second ALU Operand is the second register file output. Second ALU Operand is the sign extended offset (16 bit to 32 bits) PCSrc PC = PC + 4 (For sequential exec.) PC is replaced by branch target. MemRead - Data memory contents designated by address input are put in Read Data Output. MemWrite - Data memory contents designated by address input are put in Write Data Output. MemtoReg Write Data is fed input from ALU. Write Data is fed input from Data Memory. Table 1. Different Control Signals for the different MUXs With the exception of the PCSrc control line, the control unit can set all of the control signals based only on the opcode field of the instruction. If the instruction is branch on equal and the ALU's Zero output is asserted, then the PCSrc control line should also be asserted. We must AND the Zero signal from the ALU with the Branch signal from the control unit in order to produce the PCSrc signal.","title":"Main Control Unit (Main Decoder)"},{"location":"SingleCycle/#alu-control-unit-alu-decoder","text":"Depending on the instruction class, the ALU will need to perform one of these functions. Table 2. ALU Control Lines The main decoder determines a 2-bit ALUOp signal which is used as input for ALU Decoder along with the 6-bit funct (or function) field in the low-order bits of the instruction. The 4 bit output signal of the ALU Control Unit represents the operation to be carried out by the ALU. Fig 4. ALU Hardware Implementation The 2 bit ALUOp sent by the Control Unit indicates whether the operation to be performed should be add (00) for loads and stores, subtract (01) for beq, or determined by the operation encoded in the funct field (10).","title":"ALU Control Unit (ALU Decoder)"},{"location":"SingleCycle/#understanding-the-optimal-implementation","text":"Using multiple levels of control can reduce the size of the main control unit. Using several smaller control units may also potentially increase the speed of the control unit. Such optimizations are important, since the speed of the control unit is often critical to clock cycle time","title":"Understanding the optimal implementation:"},{"location":"SingleCycle/#alu-control-truth-table","text":"","title":"ALU Control Truth Table"},{"location":"SingleCycle/#input-output-truth-table","text":"","title":"Input-Output Truth Table"},{"location":"SingleCycle/#4-datapath","text":"A datapath is the part of a computer processor that performs arithmetic and logic operations on data. It is a digital circuit that consists of registers , an arithmetic logic unit (ALU), and multiplexers . The datapath receives instructions and data from the processor's memory and performs the necessary operations specified by the instructions. The ALU performs arithmetic and logical operations on the data, and the registers store intermediate and final results. The datapath also includes multiplexers that allow the selection of different input values based on control signals. The control signals are generated by the control unit, which coordinates the operations of the datapath to execute instructions. The datapath operates on words of data. MIPS is a 32-bit architecture , so we will use a 32-bit datapath. The datapath first decodes the instruction for the control unit which then sets the different multiplexers thereby fixing the datapath. We will split the datapath into different state elements and try to learn them one by one and finally piece them together to create a complete datapath.","title":"4. Datapath"},{"location":"SingleCycle/#state-elements","text":"There are 5 main state elements required for building the datapath.","title":"State elements"},{"location":"SingleCycle/#a-instruction-memory","text":"The program counter contains the address of the instruction to be executed. The first step is to read this instruction from the element called instruction memory. The instruction memory takes the address in PC as the input and fetches the 32 bit instruction, labelled instr. The processor\u2019s actions depend on the specific instruction that was fetched.","title":"a Instruction Memory"},{"location":"SingleCycle/#b-register-file","text":"The register file contains all the available registers. It has two read ports and one write port. Since MIPS architecture contains 32 registers, each register is identified by a unique 5 bit number (log2 32). This unique 5 bit number is given as the input in both read and write ports. The contents of the registers specified via the read ports are given as the output. If the control signal RegWrite is set, the data given in the data port is written into the register given in the write port.","title":"b Register File"},{"location":"SingleCycle/#c-alu","text":"ALU performs different arithmetic operations on the data depending on the signal received from the control unit. It has two data input ports and an input from the control unit which specifies the operation to be performed. The final result is output through ALU result and zero port is set to 1 if the result is zero.","title":"c) ALU"},{"location":"SingleCycle/#d-data-memory","text":"The memory unit is a state element with inputs for the address and the write data, and a single output for the read result.There are separate read and write controls, called MemRead and MemWrite. Only one of these may be asserted at a time. If MemRead is set then value at the address given is fetched and outputted through the read data port. If MemWrite is set then the value at the address is changed to write data.","title":"d Data Memory"},{"location":"SingleCycle/#e-sign-extension","text":"To understand what sign extension is, let\u2019s take an example. Consider the 4 bit number 1100. If we were to sign extend it to an 8 bit number, we take the MSB which in this case is 1 and extend it to make the upper half of the 8 bit number keeping the lower same as the initial 4 bits which gives us 1111 1100. Similarly, this element sign extends a 16 bit number into a 32 bit number. Now that we have seen the different state elements involved in a datapath, let's see the datapath followed by different MIPS instructions. Since we are considering MIPS microprocessor, each instruction is 32 bits long. add It is an R-type instruction of the form add $rd,$rs,$rt The R-type instruction format is The datapath for add instruction is as follows : Grab the instruction address from the PC. Decode instruction. Pass rs,rt and rd into read register and write register ports. Retrieve data from read register 1 and register 2 (rs and rt). Pass contents of rs and rt into the ALU as operands for the addition operation. The only difference between different arithmetic operations is in the ALU operation performed. Return back the ALU result to the register file as the Write data argument. The data will be written into the Write register specified by the rd field. Increment the value of PC to PC+4 to move on to the next instruction. lw(load word) The lw instruction is of the form lw $rt immediate($rs) . It has an I-type instruction format. The load word instruction copies the data stored at the address \u2018immediate+value(rs)\u2019 and stores it into the register rt. The datapath for lw instruction is as follows :- The instruction memory reads the PC and outputs the instruction. The control unit examines the most significant five bits of the instruction to determine the necessary datapath configuration. The register file receives the two register numbers rs and rt, with rs connected to the read port and rt to the write port. Read data 1 port outputs the data stored in rs. This output is then added to the sign-extended immediate using ALU. The ALU result is sent to the data memory unit, which reads the data stored at the address specified by the ALU result. Finally, the data read from the memory is returned to the register file, which writes it into register rt. PC is incremented to PC+4. sw(store word) sw instruction is of the form v sw $rt immediate($rs) The instruction format is again of the form I-type with an opcode 43. The store word instruction writes the data stored in the register rt into the memory address \u2018value(rs)+immediate \u2019. The datapath for sw instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five bits and determines the necessary datapath configuration by setting the multiplexers. The register file receives two register numbers rs and rt, with rs connected to read port1 and rt connected to read port2. The data stored in registers rs and rt is output through the read data port1 and read data port2 respectively. The read data1 is then added to the sign-extended immediate using ALU. The ALU result along with read data2 (which contains the value stored in register rt) is sent to the data memory unit, which writes the read data2 into the address specified by the ALU result. PC is incremented to PC+4. beq (branch if equal) The beq instruction is of the form beq $rs ,$rt ,immediate It has an I-type instruction format. It compares the contents of rs and rt to check if they are equal and uses the 16-bit immediate field to compute the target address of the branch relative to the current address. The datapath for beq instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five its and determines the necessary datapath configuration. The register file receives two register numbers rs and rt in the read register port and outputs the contents in rs and rt. ALU subtracts the value of rs from rt and sets the zero port to 1 if the result is 0. The immediate value is sign extended and then shifted left by 2 bits. PC is incremented to PC+4 and is added with the immediate value to give the branch target. PC is changed to the branch target if zero port was set to 1. j (jump) The jump instruction is of the form j targaddr. It has a J-type instruction format with opcode 2. This instruction uses the 26 bit targaddr to compute jump address and updates the value of PC to jump address. The datapath for j instruction is as follows :- The instruction memory reads the PC and outputs the instruction. Control unit examines the most significant five bits and determines the necessary datapath configuration. The 26 bit targaddr is shifted left by 2 bits to create a 28 bit result Concatenate the result with the upper 4 bits of PC+4 to get the jump address. Finally, the PC gets updated to the jump address.","title":"e) Sign extension"},{"location":"SingleCycle/#the-final-datapath","text":"Fig 4. Simple datapath with control unit (for R-type and I-type) Here, the input to the control unit is the 6-bit opcode field from the instruction. The outputs are the control signals which serve various purposes :- RegDst , ALUSrc , MemtoReg - 1-bit signals that control the multiplexors. RegWrite , MemRead , MemWrite - Signals that control reads and writes in the data memory and register file. Branch - Signal used in checking if a branch is required. ALUOp - 2-bit control signal for the ALU. Note that here, the AND gate is used to combine the Branch control signal with the Zero output from the ALU. This is responsible for the selection of the next PC.","title":"The Final Datapath"},{"location":"SingleCycle/#role-of-multiplexors","text":"As seen above, there are 4 multiplexors required at various stages of the datapath. They are needed in order to implement both R-type and I-type instructions using the same datapath. Their roles are explained below :- MUX 1 - This MUX determines which register needs to be written into using the RegDst control signal. If it\u2019s 0, the write register number comes from the rt field (in the case of I-type), whereas if it\u2019s 1, the write register number comes from the rd field (for R-type instructions) MUX 2 - This MUX is placed at the ALU input with ALUSrc as the select line. When it\u2019s 0, an arithmetic-logical instruction is taking place, and the second ALU operand is the data read from the second register. When it\u2019s 1, a memory instruction is taking place, with the second ALU operand being the sign-extended 16-bit immediate field from instruction. MUX 3 - It chooses which value is stored in the destination register using the MemtoReg control signal. This value comes from the ALU (for an R-type instruction) or the memory (for a load). MUX 4 - The final MUX is used to select if the PC moves onto the sequentially following instruction address (PC + 4) or branches to a target address. The control signal that achieves this is the output of the AND gate which is 1 in case of a branch instruction and 0 otherwise. Fig 4. Datapath with Jump implementation Additionally to implement the Jump instruction in the same datapath, an additional MUX, controlled by the jump control signal, is used to determine whether to move to the jump target address or the next consequent instruction. This jump target is obtained by shifting the lower 26 bits of the jump instruction left 2 bits (ie. multiplying by 4) and then concatenating the upper 4 bits of PC + 4 as the high-order bits, thus yielding a 32-bit address.","title":"Role of Multiplexors"},{"location":"SingleCycle/#5-implementation","text":"","title":"5. Implementation"},{"location":"SingleCycle/#1-top-level-module","text":"module top (input clk, reset, output [31:0] writedata, dataadr, output memwrite); wire [31:0] pc, instr, readdata; // instantiate processor and memories mips mips (clk, reset, pc, instr, memwrite, dataadr, writedata, readdata); imem imem (pc[7:2], instr); dmem dmem (clk, memwrite, dataadr, writedata,readdata); endmodule The top level module instantiates 3 sub modules mips , imem and dmem The mips module is the main processor that is responsible for executing instructions. The imem module is the instruction memory, which contains the program instructions. The dmem module is the data memory, which is used for load/store instructions. Here is a brief description of the input and output ports of the top module:","title":"1. Top level module"},{"location":"SingleCycle/#inputs","text":"clk - the clock signal used to synchronise the processor. reset - the reset signal used to initialise the processor.","title":"Inputs"},{"location":"SingleCycle/#outputs","text":"writedata - the data to be written to memory. dataadr - the memory address to access. memwrite - the control signal for writing to memory. pc - the program counter, which contains the memory address of the current instruction. instr - the current instruction being executed. readdata - the data read from memory. Overall, the top module provides the infrastructure to execute programs on the MIPS processor. It loads the program instructions from memory, executes them, and stores the results back into memory if necessary. RTL view of top level module","title":"Outputs"},{"location":"SingleCycle/#2-data-memory","text":"module dmem (input clk, we, input [31:0] a, wd, output [31:0] rd); reg [31:0] RAM[63:0]; assign rd RAM[a[31:2]]; // word aligned always @ (posedge clk) if (we) RAM[a[31:2]] wd; endmodule dmem represents a random access memory (RAM) block that can store and retrieve 32-bit data values.","title":"2. Data Memory"},{"location":"SingleCycle/#inputs-","text":"clk MemWrite we - control signal that determines whether to write data to memory. 32 bit memory address a 32 bit WriteData \u2018wd\u2019- data to be written to the location specified by a .","title":"Inputs-"},{"location":"SingleCycle/#output-","text":"32 bit ReadData rd - data read from memory location a . The dmem module contains a RAM that stores 64 words each of size 32 bits. When the we input is set to 1, the 32 bit data wd gets written into the memory location a at the positive edge of clk .","title":"Output-"},{"location":"SingleCycle/#3-instruction-memory","text":"module imem (input [5:0] a,output [31:0] rd); reg [31:0] RAM[63:0]; integer i; initial begin $readmemh (\"E:\\memfile.dat\",RAM); end assign rd = RAM[a]; // word aligned endmodule Input : 6 bit address a : This is generated by the mips module. Output : 32 bit instruction rd : The instructions are stored initially in a file called memfile.dat. This file gets loaded into the RAM array using the $readmemh system task. The $readmemh system task reads a memory file in HEX format and initialises the memory array with these values. The syntax is : $readmemh(\"hex_memory_file.mem\", memory_array,[start_address],[end_address]) (The start and end address arguments are optional) The imem module is a combinational logic block which is driven by the RAM array. The input address a is used to index into the RAM array to retrieve the instruction located at that address. The instruction is then assigned to rd . RTL view of Instruction Memory","title":"3. Instruction Memory"},{"location":"SingleCycle/#4-mips","text":"module mips(input clk, reset, output [31:0] pc, input [31:0] instr, output memwrite, output [31:0] aluout, writedata, input [31:0] readdata); wire memtoreg, branch, alusrc, regdst, regwrite, jump; wire [2:0] alucontrol; controller c(instr[31:26], instr[5:0], zero, memtoreg, memwrite, pcsrc, alusrc, regdst, regwrite, jump, alucontrol); datapath dp(clk, reset, memtoreg, pcsrc,alusrc, regdst, regwrite, jump,alucontrol,zero, pc, instr,aluout, writedata, readdata); endmodule Inputs : clk reset instr - current instruction being executed. 32 bit readdata - data read from the memory. Outputs : 32 bit pc - current program counter. 32 bit aluout - result of ALU operation(i applicable). 32 bit writedata memwrite - control signal (discussed earlier). The mips module instantiates two other modules, controller and datapath , which work together to execute instructions. Both these modules are discussed in detail in the upcoming sections. Overall the mips module acts like a traffic signal, directing the flow of data and control signals between the datapath and controller modules to execute instructions and maintain the processor\u2019s state. RTL view of MIPS module","title":"4. MIPS"},{"location":"SingleCycle/#5-controller","text":"module controller (input [5:0] op, funct, input zero, output memtoreg, memwrite, output pcsrc, alusrc, output regdst, regwrite, output jump, output [2:0] alucontrol); wire [1:0] aluop; wire branch; maindec md (op, memtoreg, memwrite, branch,alusrc, regdst, regwrite, jump,aluop); aludec ad (funct, aluop, alucontrol); assign pcsrc = branch & zero; endmodule Inputs- 6 bit Opcode 6 bit funct Zero bit (for PCSrc) Outputs- 7 control signals memtoreg memwrite pcsrc alusrc regdst regwrite jump 3 bit alu control Temporary Variables 2 bit AluOP Branch bit","title":"5. Controller"},{"location":"SingleCycle/#working","text":"It acts as a top level module connecting the main decoder and alu decoder. It has some additional logic to make the PCSrc control signal by AND-ing the branch (intermediate) signal from the main decoder and the Zero from the ALU. RTL View of Main Controller","title":"Working"},{"location":"SingleCycle/#6-main-decoder","text":"module maindec(input [5:0] op, output memtoreg, memwrite, output branch, alusrc, output regdst, regwrite, output jump, output [1:0] aluop); reg [8:0] controls; assign {regwrite, regdst, alusrc, branch, memwrite, memtoreg, jump, aluop} = controls; always @ (*) case(op) 6'b000000: controls <= 9'b110000010; //Rtype 6'b100011: controls <= 9'b101001000; //LW 6'b101011: controls <= 9'b001010000; //SW 6'b000100: controls <= 9'b000100001; //BEQ 6'b001000: controls <= 9'b101000000; //ADDI 6'b000010: controls <= 9'b000000100; //J default: controls <= 9'bxxxxxxxxx; //??? endcase endmodule Input : 6 Bit Opcode Outputs : memtoreg memwrite branch alusrc regdst regwrite jump (These 7 represent the 7 control signals which originate from the Control Unit and are explained in Theory section Table 1) 1. 2 Bit ALUOp","title":"6. Main Decoder"},{"location":"SingleCycle/#temporary-variables","text":"9 bit register control - It represents all the control signals together for easier assignment during the case statement.","title":"Temporary Variables"},{"location":"SingleCycle/#working_1","text":"It is the main decoder which sets the control signals to 1s and 0s according to the opcode instruction. It uses a switch-case statement to decide what control to set inside a \u201calways\u201d procedural block. Note: always@(*) blocks are used to describe Combinational Logic , or Logic Gates. * sets the sensitivity list of the \u201calways\u201d to any values that can have an impact on a value(s) determined by the always@(*) block. RTL View of Main Decoder","title":"Working"},{"location":"SingleCycle/#7-alu-decoder","text":"module aludec (input [5:0] funct, input [1:0] aluop, output reg [2:0] alucontrol); always @ (*) case (aluop) 2'b00: alucontrol <= 3'b010; // add 2'b01: alucontrol <= 3'b110; // sub default: case(funct) // RTYPE 6'b100000: alucontrol <= 3'b010; // ADD 6'b100010: alucontrol <= 3'b110; // SUB 6'b100100: alucontrol <= 3'b000; // AND 6'b100101: alucontrol <= 3'b001; // OR 6'b101010: alucontrol <= 3'b111; // SLT default: alucontrol <= 3\u2019bxxx; // ??? endcase endcase endmodule ```` Inputs : 1. 16 bit ```funct``` (from 32 bit MIPS Instruction) 2. 2 bit ```ALUOp``` (coming from Main decoder) Output : 1. 3 bit ALU control Working It decides what function the ALU will carry out. It works with a nested switch-case statement. First it checks the ```ALUop``` 1. If ```ALUOp``` = 1 -> ALU has to perform addition. (lw,sw) 2. If ```ALUOp``` = 2 -> ALU has to perform subtraction. (beq) 3. If ```ALUOp``` = 3 -> It depends on the 6 bit funct which will ADD, SUB, AND, OR, SLT (R-type) ![aludec](./2024%20Single%20Cycle%20Images/singlecycle-0113.png) RTL View of ALU Decoder ## 8. Datapath ```v module datapath (input clk, reset, input memtoreg, pcsrc, input alusrc, regdst, input regwrite, jump, input [2:0] alucontrol, output zero, output [31:0] pc, input [31:0] instr, output [31:0] aluout, writedata, input [31:0] readdata); wire [4:0] writereg; wire [31:0] pcnext, pcnextbr, pcplus4, pcbranch; wire [31:0] signimm, signimmsh; wire [31:0] srca, srcb; wire [31:0] result; // next PC logic flopr #(32) pcreg(clk, reset, pcnext, pc); adder pcadd1 (pc, 32b100, pcplus4); sl2 immsh(signimm, signimmsh); adder pcadd2(pcplus4, signimmsh, pcbranch); mux2 #(32) pcbrmux(pcplus4, pcbranch, pcsrc,pcnextbr); mux2 #(32) pcmux(pcnextbr, {pcplus4[31:28], instr[25:0], 2b00},jump, pcnext); // register file logic regfile rf(clk, regwrite, instr[25:21],instr[20:16], writereg,result, srca, writedata); mux2 #(5) wrmux(instr[20:16], instr[15:11], regdst, writereg); mux2 #(32) resmux(aluout, readdata, memtoreg, result); signext se(instr[15:0], signimm); // ALU logic mux2 #(32) srcbmux(writedata, signimm, alusrc,srcb); alu alu(srca, srcb, alucontrol,aluout, zero); endmodule Inputs : clk reset (They are external inputs.) memwrite regwrite regdst alusrc memtoreg pcsrc jump (They are the control signals from the main decoder.) 32 bit instr - output of the instruction memory. 32 bit readdata - output of the data memory. 3 bit alucontrol - output of the alu decoder. Outputs : zero 32 bit pc 32 bit aluout 32 bit writedata Working : The datapath is separated into 3 sections:- next PC logic The pseudocode for this section is- { always@(poseedge clk && poseedge reset) pc=pcnext; pcplus4=pc+4; signimm=signextend to 32 bits instr[15:0] signimmsh=shift left 2 of signimmsh pcbranch=pcplus4+signimmsh jump address= {pcplus4[31:28],instr[25:0], 2b00} if(pcsrc==0) pcnextbr=pcplus4; else pcnextbr=pcbranch; if(jump==0) pcnext=pcnextbr; else pcnext=jump address; } register file logic The pseudocode for this section is- { if(regdst==0) writereg=instr[20:16]; else writereg=instr[15:11]; if(memtoreg==0) result=aluout; else result=readdata; in registerfile { read register1=instr[25,21]; read register2=instr[20:16]; write register=writereg; write data=result; } } ALU In this section the ALU performs operations on \u2018srca\u2019(output of register file) and \u2018srcb\u2019 (depends on control signal alusrc) depending on the value of \u2018alucontrol\u2019. RTL view of datapath","title":"7. ALU Decoder"},{"location":"SingleCycle/#9-three-ported-register","text":"module regfile (input clk, input we3, input [4:0] ra1, ra2, wa3, input [31:0] wd3, output [31:0] rd1, rd2); reg [31:0] rf[31:0]; always @ (posedge clk) if (we3) rf[wa3] <= wd3; assign rd1 = (ra1 != 0) ? (rf[ra1]) : 0; assign rd2 = (ra2 != 0) ? (rf[ra2]): 0; endmodule Inputs : Clk signal for third port Read register 1 ra1 Read register 2 ra2 Write register wa3 Write data we3 Outputs : Read data 1 rd1 Read data 2 rd2 Temporary Variables : 32 element Array of 32 bit registers Working : Two ports read combinationally. Third port written on the rising edge of the clock. If any of the registers are \u20180\u2019 it is hardwired to be 0 value by default. RTL View of Register File","title":"9. Three ported Register"},{"location":"SingleCycle/#10-some-other-functional-units","text":"These units were explained in previous modules. As such explanation and theory is not repeated and can be referred to from those modules.","title":"10. Some Other Functional Units"},{"location":"SingleCycle/#1-adder-module","text":"module adder (input [31:0] a, b,output [31:0] y); assign y=a + b; endmodule","title":"1. ADDER MODULE"},{"location":"SingleCycle/#2-shift-left-by-2-module","text":"module sl2 (input [31:0] a, output [31:0] y); assign y = {a[29:01], 2'b00}; endmodule","title":"2. SHIFT LEFT BY 2 MODULE"},{"location":"SingleCycle/#3-sign-extension-module","text":"module signext (input [15:0] a,output [31:0] y); assign y={{16{a[15]}}, a}; endmodule First 16 bits of 32 bit Y are assigned the value of A[15] thus extending A by 16 bits.","title":"3. SIGN EXTENSION MODULE"},{"location":"SingleCycle/#4-d-flip-flop-module-with-variable-width","text":"module flopr # (parameter WIDTH = 8)(input clk, reset,input [WIDTH-1:0] d,output reg [WIDTH-1:0] q); always @ (posedge clk, posedge reset) if (reset) q<=0; else q <= d; endmodule","title":"4. D FLIP FLOP MODULE (with variable width)"},{"location":"SingleCycle/#5-2-way-mux-module-with-variable-width","text":"module mux2 # (parameter WIDTH = 8)(input [WIDTH-1:0] d0, d1,input s,output [WIDTH-1:0] y); assign y = s ? d1 : d0; endmodule","title":"5. 2 WAY MUX MODULE (with variable width)"},{"location":"SingleCycle/#6-32-bit-alu-module","text":"module alu(i_data_A, i_data_B, i_alu_control,o_result,o_zero_flag); input [31:0] i_data_A; // A operand input [31:0] i_data_B; // B operand output reg [31:0] o_result; // ALU result input [3:0] i_alu_control; // Control signal output wire o_zero_flag; // Zero flag assign o_zero_flag = ~|o_result; always @(*) begin // Start initialization: casex(i_alu_control) 4'b0010: // ADD begin o_result = i_data_A + i_data_B; end 4'b0110: // SUB begin o_result = i_data_A - i_data_B; end 4'b0000: // AND begin o_result = i_data_A & i_data_B; end 4'b0001: // OR begin o_result = i_data_A | i_data_B; end 4'b0111: // SLT begin o_result = i_data_A < i_data_B ? 32'h00000001: 32'h00000000; end 4'b0011://XOR begin o_result=i_data_A^i_data_B; end 4'b0100://NOR begin o_result=~(i_data_A | i_data_B); end default: begin o_result={32{1'bx}}; //x-state,(nor1,nor0) end endcase end endmodule","title":"6. 32 BIT ALU MODULE"},{"location":"SingleCycle/#6-how-to-run-instructions","text":"Great! Now we have our single cycle microprocessor ready but how do we run assembly code in it? The following steps explain that in detail. ( Since its a MIPS implementation of a 32 Bit Microprocessor we shall use MIPS code as the assembly code. ) Steps to run Write Down the MIPS code you want to execute. Your code should have an instance of the instruction you want to test. Make sure the set of instructions ends with a store word (sw) instruction. The output of this \u201cstore word\u201d should be dependent on the instruction to be tested. (This will be used for checking if the instruction is executed correctly or not.) Convert the MIPS Code into machine code with the help of an online convertor. Save the machine code as \u201cmemfile.dat\u201d in your preferred directory. Update the path (line 6) of \u201cmemfile.dat\u201d in the imem module (Instruction Memory) of your Verilog code to the absolute path of the memfile.dat Change the test bench to check the following dataaddr- should contain the address of the last store word (X) in the last line of our machine code in memfile.dat writedata- should contain the data being written in memory (Y) in the last store word instruction. So, in the testbench make the change : (dataadr === X & writedata === Y ) Save the module and compile your Verilog code. Run RTL Simulation. The transcript section should contain \u201cSimulation succeeded\u201d in the case of a correct implementation and matching dataaddr and writedata. Fig. Sample transcript output","title":"6. How to Run Instructions"},{"location":"SingleCycle/#7-test-cases-for-various-instructions","text":"Now we will try to check if our microprocessor implements instructions properly.","title":"7. Test cases for Various Instructions"},{"location":"SingleCycle/#1-add","text":"addi $2, $0, 450 //initialise $2 =450 addi $3, $0, 550 //initialise $3 =550 add $4, $2, $3 //$4=$2+$3 ,$4=450+550=1000 sw $4, 20($0) //write address 20 = 1000 Machine code 200201c2 20030226 00432020 ac040014 If the value at address location 20 is 1000,then the add instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 1000) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule","title":"1. add"},{"location":"SingleCycle/#2-sub","text":"addi $2,$0, 550 //initialise $2 =550 addi $3,$0, 550 //initialise $3 =550 sub $4,$2, $3 //$4=$2+$3 , $4=550-550=0 sw $4, 50($0) //write address 50 = 0 Machine code : 20020226 20030226 00432022 ac040032 If the value at address location 50 is 0,then the sub instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end //check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 50 & writedata === 0) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule","title":"2. sub"},{"location":"SingleCycle/#3-sw","text":"addi $2,$0,25 //initialise $2 =25 sw $2, 30($0) //write address 30 = 25 Machine code : 20020019 ac02001e If the value at address location 30 is 25,the sw instruction is working properly. The testbench to check the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 30 & writedata === 25) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule","title":"3. sw"},{"location":"SingleCycle/#4-lw","text":"addi $2,$0,100 //initialise $2 =100 sw $2,30($0) //write address 30 = 100 lw $3,30($0) //$3=[30] = 100 sw $3,20($0) //write address 20 = 100 Machine code 20020064 ac02001e 8c03001e ac030014 If the value at address location 20 is 100, then lw instruction is working properly. The testbench to check the same is:\\ module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 100) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 30) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule","title":"4. lw"},{"location":"SingleCycle/#5-beq","text":"main: addi $2,$0,20 //initialise $2 =20 addi $3,$0,30 //initialise $3 =30 addi $5,$0,0 //initialise $5 =0 beq $5,$0,end //if val($5)==val($0) branch to \u2018end\u2019 add $5,$2,$3 //$5=$2+$3 end: sw $5, 20($0) //write address 20 = 0 Machine code: 20020014 2003001e 20050000 10a00002 00432820 ac050014 If the value at address location 20 is 0,then the beq instruction is executed properly. The testbench for the same is: module testbenchv1; reg clk; reg reset; integer i; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device to be tested top dut (clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset <= 1; # 22; reset <= 0; end // generate clock to sequence tests always begin clk <= 1; # 5; clk <= 0; # 5; end // check results always @ (negedge clk) begin if (memwrite) begin if (dataadr === 20 & writedata === 0) begin $display (\"Simulation succeeded\"); $stop; end else if (dataadr !== 80) begin $display (\"Failed hehe %h and %h\",writedata,dataadr); $stop; end end end endmodule","title":"5. beq"},{"location":"SingleCycle/#8-references","text":"\"Computer Organization and Design: The Hardware/Software Interface\" by David Patterson and John Hennessy \u201cDigital design and Computer architecture\u201d by David Money Harris & Sarah L. Harris. \u201cDigital Logic and Computer Design \u201dby M. Morris Mano. \u201cVerilog HDL: A Guide to Digital Design and Synthesis \u201d by Samir Palnitkar.","title":"8. References"},{"location":"about/","text":"About Us Welcome to the Hardware Lab at Computer Science and Engineering Department of National Institute of Technology, Calicut. We are a team of dedicated individuals who have come together to create a comprehensive resource for students studying computer hardware in the department. Our Philosophy Our mission is to provide students with a valuable tool that enhances their learning experience in the hardware lab course. We aim to simplify complex concepts, offer practical tips, and provide step-by-step guides to help students excel in their studies. The Computer Science Department The Computer Science Department of NITC is a leading academic department that fosters innovation, research, and excellence in the field of computer science. Our department offers a wide range of courses and programs designed to equip students with the knowledge and skills required to thrive in the ever-evolving world of technology.For more information visit https://minerva.nitc.ac.in/ The Hardware Lab Course Guide Team Faculty :fontawesome-solid-computer: Prof. Srinivasa TM Prof. Nirmal Kumar Boran The MIPS Team :simple-linkedin: Mohammad Saad Naeem Niaz Chandrakant V Bellary Mithunraj M Abel Mani Roy The Verilog Team :simple-linkedin: Arshiya P Hafis Avinash Kumar Akshit Kumar Aritro Ghosh Arjun Krishna Web and Repository Maintenance :simple-github: Mohammad Saad Aritro Ghosh Join Our Team We are always looking to expand our team and welcome individuals who share our passion for computer hardware education. If you are interested in contributing to the Hardware Lab Course Guide or have any suggestions, we would love to hear from you. Please reach out to us at hwlab_csed@nitc.ac.in :octicons-mail-16: Thank you for visiting the Computer Science Department's Hardware Lab Course Guide. We hope this resource serves as a valuable tool for your studies and contributes to your success in the fascinating world of computer hardware.","title":"About Us"},{"location":"about/#about-us","text":"Welcome to the Hardware Lab at Computer Science and Engineering Department of National Institute of Technology, Calicut. We are a team of dedicated individuals who have come together to create a comprehensive resource for students studying computer hardware in the department.","title":"About Us"},{"location":"about/#our-philosophy","text":"Our mission is to provide students with a valuable tool that enhances their learning experience in the hardware lab course. We aim to simplify complex concepts, offer practical tips, and provide step-by-step guides to help students excel in their studies.","title":"Our Philosophy"},{"location":"about/#the-computer-science-department","text":"The Computer Science Department of NITC is a leading academic department that fosters innovation, research, and excellence in the field of computer science. Our department offers a wide range of courses and programs designed to equip students with the knowledge and skills required to thrive in the ever-evolving world of technology.For more information visit https://minerva.nitc.ac.in/","title":"The Computer Science Department"},{"location":"about/#the-hardware-lab-course-guide-team","text":"","title":"The Hardware Lab Course Guide Team"},{"location":"about/#faculty-fontawesome-solid-computer","text":"Prof. Srinivasa TM Prof. Nirmal Kumar Boran","title":"Faculty :fontawesome-solid-computer:"},{"location":"about/#the-mips-team-simple-linkedin","text":"Mohammad Saad Naeem Niaz Chandrakant V Bellary Mithunraj M Abel Mani Roy","title":"The MIPS Team :simple-linkedin:"},{"location":"about/#the-verilog-team-simple-linkedin","text":"Arshiya P Hafis Avinash Kumar Akshit Kumar Aritro Ghosh Arjun Krishna","title":"The Verilog Team :simple-linkedin:"},{"location":"about/#web-and-repository-maintenance-simple-github","text":"Mohammad Saad Aritro Ghosh","title":"Web and Repository Maintenance :simple-github:"},{"location":"about/#join-our-team","text":"We are always looking to expand our team and welcome individuals who share our passion for computer hardware education. If you are interested in contributing to the Hardware Lab Course Guide or have any suggestions, we would love to hear from you. Please reach out to us at hwlab_csed@nitc.ac.in :octicons-mail-16: Thank you for visiting the Computer Science Department's Hardware Lab Course Guide. We hope this resource serves as a valuable tool for your studies and contributes to your success in the fascinating world of computer hardware.","title":"Join Our Team"},{"location":"mips_main/","text":"Welcome to the MIPS Guide This course covers the following topics- Introduction to MIPS - Setting up and understanding MIPS ISA. Basic Integer and String Handling - Learn the Basics of MIPS integers. Integer Array Handling - Learn how to make integer arrays and operate them. 2-D Array Handling - Extend your array knowledge with 2-D arrays. Strings (Advanced) - String Handling explained in detail. Floating Points - Learn how to handle floating point numbers. Introduction to MIPS \u2003\u2003Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory explanation: Video Link :simple-youtube: \u2003\u2003Setting up MARS: \u2003\u2003\u2003\u2003 1. Video Link :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: Basic Integer and String Handling \u2003\u2003Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory Explanation: Video Link :simple-youtube: \u2003\u2003Sample Code Bank: \u2003\u2003\u2003\u2003 1. Reversing 2 digit number \u2003\u2003\u2003\u2003 2. Calculating Average Marks \u2003\u2003\u2003\u2003 3. Finding Spy Number Floating Point Handling \u2003\u2003Main Documentation :material-google-drive: : Click Here \u2003\u2003Farenheit to Celcius: \u2003\u2003\u2003\u2003 Sample Code :simple-github: \u2003\u2003Maximum and Minimum in Float Array: \u2003\u2003\u2003\u2003 Sample Code :simple-github: \u2003\u2003 Round off to n digits: \u2003\u2003\u2003\u2003 Sample Code :simple-github: Integer Array Handling \u2003\u2003Main Documentation (Also contains String advanced):material-google-drive: : Click Here \u2003\u2003Introduction to Integer Arrays: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Sum of Elements of an Array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Greatest Element in Array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Merge 2 Sorted Arrays: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Highest and Lowest occurrence of an element in an array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Binary Search: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Quicksort: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: 2-D Integer Array Handling \u2003\u2003Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory Explanation: Video Link :simple-youtube: \u2003\u2003Sample Code Bank: \u2003\u2003\u2003\u2003 1. Taking Input \u2003\u2003\u2003\u2003 2. Printing a Matrix \u2003\u2003\u2003\u2003 3. Sum of Two Matrices String Handling (advanced) \u2003\u2003Input/Output of Strings: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Traversal of Strings (Advanced string operations): \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Length of String: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Palindrome Check: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Concatenation of strings: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github:","title":"MIPS"},{"location":"mips_main/#welcome-to-the-mips-guide","text":"This course covers the following topics-","title":"Welcome to the MIPS Guide"},{"location":"mips_main/#_1","text":"Introduction to MIPS - Setting up and understanding MIPS ISA. Basic Integer and String Handling - Learn the Basics of MIPS integers. Integer Array Handling - Learn how to make integer arrays and operate them. 2-D Array Handling - Extend your array knowledge with 2-D arrays. Strings (Advanced) - String Handling explained in detail. Floating Points - Learn how to handle floating point numbers.","title":""},{"location":"mips_main/#introduction-to-mips","text":"Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory explanation: Video Link :simple-youtube: \u2003\u2003Setting up MARS: \u2003\u2003\u2003\u2003 1. Video Link :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github:","title":"Introduction to MIPS"},{"location":"mips_main/#basic-integer-and-string-handling","text":"Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory Explanation: Video Link :simple-youtube: \u2003\u2003Sample Code Bank: \u2003\u2003\u2003\u2003 1. Reversing 2 digit number \u2003\u2003\u2003\u2003 2. Calculating Average Marks \u2003\u2003\u2003\u2003 3. Finding Spy Number","title":"Basic Integer and String Handling"},{"location":"mips_main/#floating-point-handling","text":"Main Documentation :material-google-drive: : Click Here \u2003\u2003Farenheit to Celcius: \u2003\u2003\u2003\u2003 Sample Code :simple-github: \u2003\u2003Maximum and Minimum in Float Array: \u2003\u2003\u2003\u2003 Sample Code :simple-github: \u2003\u2003 Round off to n digits: \u2003\u2003\u2003\u2003 Sample Code :simple-github:","title":"Floating Point Handling"},{"location":"mips_main/#integer-array-handling","text":"Main Documentation (Also contains String advanced):material-google-drive: : Click Here \u2003\u2003Introduction to Integer Arrays: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Sum of Elements of an Array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Greatest Element in Array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Merge 2 Sorted Arrays: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Highest and Lowest occurrence of an element in an array: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Binary Search: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Quicksort: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github:","title":"Integer Array Handling"},{"location":"mips_main/#2-d-integer-array-handling","text":"Main Documentation :material-google-drive: : Click Here \u2003\u2003Theory Explanation: Video Link :simple-youtube: \u2003\u2003Sample Code Bank: \u2003\u2003\u2003\u2003 1. Taking Input \u2003\u2003\u2003\u2003 2. Printing a Matrix \u2003\u2003\u2003\u2003 3. Sum of Two Matrices","title":"2-D Integer Array Handling"},{"location":"mips_main/#string-handling-advanced","text":"Input/Output of Strings: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Traversal of Strings (Advanced string operations): \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Length of String: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Palindrome Check: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github: \u2003\u2003Concatenation of strings: \u2003\u2003\u2003\u2003 1. Video :simple-youtube: \u2003\u2003\u2003\u2003 2. Sample Code :simple-github:","title":"String Handling (advanced)"},{"location":"verilog_main/","text":"Welcome to the Verilog Guide This course covers the following topics- Introduction To Verilog - Learn the Basics of Verilog HDL. Finite State Machines - Design a Verilog-based Finite State Machine (FSM) that enhances your circuits with efficient sequential control and decision-making capabilities. MIPS Single Cycle Processor - Build an exciting MIPS single cycle processor which will allow you to run MIPS hardware commands. Introduction to Verilog \u2003 Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Theory: \u2003\u2003\u2003\u2003 1. Theory Vid Part 1 (INTRO TO VERILOG-LOGIC GATES-ADDERS-SUBTRACTORS) :simple-youtube: \u2003\u2003\u2003\u2003 2. Theory Vid Part 2 (PARITY-TILL END) :simple-youtube: \u2003 Implementation : \u2003\u2003How to Run Verilog Files in Quartus: How to Run ? :simple-youtube: \u2003\u2003Sample Codes: Link to Sample Codes :simple-github: \u2003\u2003Video Explanation of Select Codes: \u2003\u2003\u2003\u2003 1. Verilog Syntax :simple-youtube: \u2003\u2003\u2003\u2003 2. Adder Subtractor :simple-youtube: \u2003\u2003\u2003\u2003 3. DEMUX :simple-youtube: \u2003\u2003\u2003\u2003 4. Counter :simple-youtube: \u2003\u2003\u2003\u2003 5. Decoder :simple-youtube: \u2003\u2003Assignment 1: Download Here Finite State Machines \u2003 Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Main Concept :simple-youtube: \u2003\u2003\u2003\u2003 2. Syntax (Optional) :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation): \u2003\u2003\u2003\u2003 Examples of FSM along with Code explanation :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 2: Download Here Single Cycle MIPS Processor \u2003 Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Control Unit Theory :simple-youtube: \u2003\u2003\u2003\u2003 2. Datapath Theory :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation) : \u2003\u2003\u2003\u2003 1. Code Modules 1 to 5 explained :simple-youtube: \u2003\u2003\u2003\u2003 2. Code Modules 6 to 10 explained :simple-youtube: \u2003\u2003\u2003\u2003 3. All Testbenches explained :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 3: Download Here","title":"Verilog"},{"location":"verilog_main/#welcome-to-the-verilog-guide","text":"This course covers the following topics-","title":"Welcome to the Verilog Guide"},{"location":"verilog_main/#_1","text":"Introduction To Verilog - Learn the Basics of Verilog HDL. Finite State Machines - Design a Verilog-based Finite State Machine (FSM) that enhances your circuits with efficient sequential control and decision-making capabilities. MIPS Single Cycle Processor - Build an exciting MIPS single cycle processor which will allow you to run MIPS hardware commands.","title":""},{"location":"verilog_main/#introduction-to-verilog","text":"Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Theory: \u2003\u2003\u2003\u2003 1. Theory Vid Part 1 (INTRO TO VERILOG-LOGIC GATES-ADDERS-SUBTRACTORS) :simple-youtube: \u2003\u2003\u2003\u2003 2. Theory Vid Part 2 (PARITY-TILL END) :simple-youtube: \u2003 Implementation : \u2003\u2003How to Run Verilog Files in Quartus: How to Run ? :simple-youtube: \u2003\u2003Sample Codes: Link to Sample Codes :simple-github: \u2003\u2003Video Explanation of Select Codes: \u2003\u2003\u2003\u2003 1. Verilog Syntax :simple-youtube: \u2003\u2003\u2003\u2003 2. Adder Subtractor :simple-youtube: \u2003\u2003\u2003\u2003 3. DEMUX :simple-youtube: \u2003\u2003\u2003\u2003 4. Counter :simple-youtube: \u2003\u2003\u2003\u2003 5. Decoder :simple-youtube: \u2003\u2003Assignment 1: Download Here","title":"Introduction to Verilog"},{"location":"verilog_main/#finite-state-machines","text":"Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Main Concept :simple-youtube: \u2003\u2003\u2003\u2003 2. Syntax (Optional) :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation): \u2003\u2003\u2003\u2003 Examples of FSM along with Code explanation :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 2: Download Here","title":"Finite State Machines"},{"location":"verilog_main/#single-cycle-mips-processor","text":"Theory : \u2003\u2003Documentation: Link to Main Documentation :simple-googledrive: \u2003\u2003Video Explanation of Concept: \u2003\u2003\u2003\u2003 1. Control Unit Theory :simple-youtube: \u2003\u2003\u2003\u2003 2. Datapath Theory :simple-youtube: \u2003 Implementation : \u2003\u2003Video Explanation of Code (From Documentation) : \u2003\u2003\u2003\u2003 1. Code Modules 1 to 5 explained :simple-youtube: \u2003\u2003\u2003\u2003 2. Code Modules 6 to 10 explained :simple-youtube: \u2003\u2003\u2003\u2003 3. All Testbenches explained :simple-youtube: \u2003\u2003Code Bank: \u2003\u2003\u2003\u2003 Link to Sample Codes :simple-github: \u2003\u2003Assignment 3: Download Here","title":"Single Cycle MIPS Processor"},{"location":"Intro/","text":"INTRODUCTION Table of Contents Topic Page Introduction 1 Verilog Syntax 2 Basic Logic Gates 3 Binary Adders and Subtractors 4 Latches 5 Flip Flops 6 Multiplexers 7 Demultiplexers 8 Parity Generator 9 Code converter 10 Comparators 11 Registers 12 Counters 13 Arithmetic Logic Unit 14 Encoders 15 Decoders 16 How ro make a verilog program 17 Bibliography 18 --- Verilog is a Hardware Description Language (HDL) . They resemble programming languages specifically oriented to describe hardware structures and their behavior. This language describes an interconnection of components. Such a structural description, a netlist, can be used as input to logic simulation just as a schematic is used. A typical procedure is used in employing an HDL description as simulation input. The steps in the procedure are analysis, elaboration, and initialization, followed by the simulation. Analysis checks the description for violations of the syntax and semantic rules for the HDL and produces an intermediate representation of the design. Elaboration traverses the design hierarchy represented by the description; in this process, the design hierarchy is flattened to an interconnection of modules described only by their behaviors. The result of the analysis and elaboration performed by the compiler is a simulation model of the original HDL description. This model is then passed to the simulator for execution. Initialization sets all of the variables in the simulation model to specified or default values. Simulation executes the simulation model in either batch or interactive mode with inputs specified by the user. The testbench is a description that includes the design to be tested, typically referred to as the Device Under Test (DUT). The testbench describes a collection of hardware and software functions that apply inputs to the DUT and analyze the outputs for correctness. Verilog supports a design at many levels of abstraction. The primary three kinds of abstraction in Verilog are - Behavioral level - Register-transfer level - Gate level Behavioral: This is the highest level of abstraction provided by Verilog HDL. It describes the circuit using procedural statements (the \"always\" block, case, and if statements). At the behavioral level, the circuit is described using an algorithm consisting of a set of instructions executed one after the other sequentially. Data-Flow: This is the second highest level of abstraction. It specifies the circuit as a combination of operations and data transfer between the registers. In this approach, the 'assign' statement is used. An assign statement is a continuous statement where any signal changes on the right-hand side will update the output signal. Changes in the inputs are continuously monitored. Any synthesizable code is called RTL code. Gate-Level: This is the lowest level of abstraction. Here, the circuit is described by logical links and their timing properties. The module is implemented in terms of logic gates and interconnections between these gates. It resembles a schematic drawing with components connected with signals. Functional Differences Behavioral Level Pros Easy to write and understand, especially for complex algorithms and high-level functionality. Portability: the same behavioral code can be synthesized into different hardware architectures. Enables early verification, allowing designers to test system functionality before committing to a particular hardware architecture. Cons Less control over the hardware implementation details. Can be less efficient in terms of area, power, and performance than lower levels of abstraction. More difficult to optimize for timing and power. Register Transfer Level (RTL) Pros Offers greater control over the hardware implementation details. Can be optimized for timing, power, and area, allowing for more efficient designs. Can be used for both simulation and synthesis. Cons More difficult to write and understand than the behavioral level. Can be less portable than the behavioral level, since the same code may not synthesize correctly across different architectures. Can be more difficult to verify than the behavioral level, since the design is more complex. Gate Level Pros Provides the most detailed view of the hardware implementation. Highly optimized for area, power, and performance. Ideal for final verification of the design. Cons Very difficult to write and understand. Not portable: The code is specific to a particular hardware architecture. Verification can be very time-consuming and difficult, especially for complex designs. VERILOG SYNTAX CODE: module half_adder(output s, c, input a, b); assign s = a ^ b; assign c = a & b; endmodule module is always terminated by endmodule . Always specify output first and then input. TESTBENCH: module half_adder_test; reg in1, in2; wire out1, out2; half_adder a1(out1,out2 ,in1, in2); reg [2:0]count; initial begin for(count=0; count<4; count = count+1) begin {in1, in2} = count[1:0]; #20; end end endmodule reg : store input values wire : store output values begin end is used to specify a block of code. BASIC LOGIC GATES Logic gates are basic building blocks of digital electronics circuits that perform logical operations on one or more binary inputs and produce a binary output. In other words, a logic gate is an electronic device that operates on logical signals (digital signals) to perform a Boolean function. There are several types of logic gates, including: AND gate: It has two or more input signals and produces a HIGH output only if all inputs are HIGH. The AND gate symbol is the dot or multiplication symbol. OR gate: It has two or more input signals and produces a HIGH output if at least one input is HIGH. The OR gate symbol is the plus symbol. NOT gate (Inverter): It has one input signal and produces the complement of the input signal at its output. The NOT gate symbol is a triangle with a circle at the output. NAND gate: It is a combination of an AND gate and a NOT gate. It produces a LOW output only if all inputs are HIGH. The NAND gate symbol is an AND gate with a small circle at its output. NOR gate: It is a combination of an OR gate and a NOT gate. It produces a HIGH output only if all inputs are LOW. The NOR gate symbol is an OR gate with a small circle at its output. XOR gate: It has two input signals and produces a HIGH output if the two inputs are different (i.e., one input is HIGH and the other is LOW). The XOR gate symbol is the addition symbol with a circle around it. XNOR gate: It is a combination of an XOR gate and a NOT gate. It produces a HIGH output if the two inputs are the same (i.e., both inputs are HIGH or both inputs are LOW). The XNOR gate symbol is an XOR gate with a small circle at its output. Binary Adders and Subtractors HALF ADDER A half-adder is an arithmetic circuit that generates the sum of two binary digits. The circuit has two inputs and two outputs. The input variables are the augend and addend bits to be added, and the output variables produce the sum and carry. The Boolean functions for the two outputs, easily obtained from the truth table, are S = XY + XY = X \u2295 Y C = XY x y C S 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 FULL ADDER A full adder is a combinational circuit that forms the arithmetic sum of three input bits. Two input variables, denoted by X and Y, represent the two significant bits to be added. The third input, Z, represents the carry from the previous lower significant position. The simplified sum-of-product functions for the two outputs are : S = XYZ + XYZ + XY Z + XYZ C = XY + XZ + YZ S = (X \u2295 Y) \u2295 Z C = XY + Z(X \u2295 Y) RIPPLE CARRY ADDER A parallel binary adder is a digital circuit that produces the arithmetic sum of two binary numbers using only combinational logic. The parallel adder uses n full adders in parallel, with all input bits applied simultaneously to produce the sum. The full adders are connected in cascade, with the carry output from one full adder connected to the carry input of the next full adder. Since a 1 carry may appear near the least significant bit of the adder and yet propagate through many full adders to the most significant bit, just as a wave ripples outward from a pebble dropped in a pond, the parallel adder is referred to as a ripple carry adder. CARRY LOOK AHEAD ADDER Define two new binary variables |Pi = Ai XOR Bi| |---| Gi = Ai AND Bi the output sum and carry can respectively be expressed as Si = Pi XOR Ci Ci+1 = Gi + (Pi AND Ci) Each sum output requires two exclusive-OR gates. The output of the first exclusive-OR gate generates the Pi variable, and the AND gate generates the Gi variable. The carries are propagated through the carry lookahead generator and applied as inputs to the second exclusive-OR gate. All output carries are generated after a delay through two levels of gates. Thus, outputs S1 through S3 have equal propagation delay times. HALF SUBTRACTOR A half subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) and produces two output bits: the difference (D) and the borrow (B). The half subtractor is called \"half\" because it can only subtract two single-bit binary numbers, unlike a full subtractor that can subtract two multi-bit binary numbers. D= A XOR B B\u2019 = Abar AND B FULL SUBTRACTOR A full subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) along with a borrow (Bin) and produces two output bits: the difference (D) and the borrow (Bout). The full subtractor is an extension of the half subtractor, which can only subtract two single-bit binary numbers. D = A XOR B XOR Bin B\u2019 = Abar AND B OR ((A XOR B)bar)Bin BINARY ADDER AND SUBTRACTOR M-N where M-minuend and N is subtrahend When performing a subtraction we complement the subtrahend N, and when performing an addition we do not complement N. The 2s complement can be obtained by taking the 1s complement and adding 1 to the least significant bit. The 1s complement can be implemented easily with inverter circuits, and we can add 1 to the sum by making the input carry of the parallel adder equal to 1. The input carry C0 must be equal to 1. The operation that is performed becomes A plus the 1s complement of B plus 1. This is equal to A plus the 2s complement of B. For unsigned numbers, it gives A - B if A >= B or the 2s complement of B - A if A <img B LATCHES SR LATCH The SR latch is a circuit constructed from two cross- coupled NOR gates. The latch has two inputs, labeled S for set and R for reset, and two useful states. When output Q = 1 and Q = 0, the latch is said to be in the set state. When Q = 0 and Q = 1, it is in the reset state. Outputs Q and Q are normally the complements of each other. When both inputs are equal to 1 at the same time, an undefined state with both outputs equal to 0 occurs. S\u0305R\u0305 LATCH The SR latch with two cross- coupled NAND gates. It operates with both inputs normally at 1, unless the state of the latch has to be changed. The application of a 0 to the S input causes output Q to go to 1, putting the latch in the set state. When the S input goes back to 1, the circuit remains in the set state. With both inputs at 1, the state of the latch is changed by placing a 0 on the R input. This causes the circuit to go to the reset state and stay there, even after both inputs return to 1. The condition that is undefined for this NAND latch is when both inputs are equal to 0 at the same time, an input combination that should be avoided. When the NAND latch requires a 0 signal to change its state, it is referred to as an SR latch. SR LATCH WITH CONTROL INPUT It consists of the basic NAND latch and two additional NAND gates. The control input C acts as an enable signal for the other two inputs. The output of the NAND gates stays at the logic- 1 level as long as the control input remains at 0. When the control input goes to 1, information from the S and R inputs is allowed to affect the S R latch. The set state is reached with S = 1, R = 0, and C = 1. To change to the reset state, the inputs must be S = 0, R = 1, and C = 1. In either case, when C returns to 0, the circuit remains in its current state. Control input C = 0 disables the circuit so that the state of the output does not change, regardless of the values of S and R. Moreover, when C = 1 and both the S and R inputs are equal to 0, the state of the circuit does not change.An undefined state occurs when all three inputs are equal to 1. This condition places 0s on both inputs of the basic S R latch, giving an undefined state. D LATCH One way to eliminate the undesirable undefined state in the SR latch is to ensure that inputs S and R are never equal to 1 at the same time. This is done in the D latch, shown in Figure 4-8. This latch has only two inputs: D (data) and C (control). The complement of the D input goes directly to the S input, and D is applied to the R input. As long as the control input is 0, the S R latch has both inputs at the 1 level, and the circuit cannot change state regardless of the value of D. The D input is sampled when C = 1. If D is 1, the Q output goes to 1, placing the circuit in the set state. If D is 0, output Q goes to 0, placing the circuit in the reset state. The D latch receives its designation from its ability to hold data in its internal storage. The binary information present at the data input of the D latch is transferred to the Q output when the control input is enabled (1). The output follows changes in the data input, as long as the control input is enabled. When the control input is disabled (0), the binary information that was present at the data input at the time the transition in C occurred is retained at the Q output until the control input C is enabled again. FLIP FLOPS There are basically 4 types of flip-flops: 1. SR Flip-Flop 2. JK Flip-Flop 3. D Flip-Flop 4. T Flip-Flop SR FLIP-FLOP SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with an enable signal. The circuit diagram of SR flip-flop is shown in the following figure.This circuit has two inputs S & R and two outputs QN and Qn+1, present and next state respectively. The operation of the SR flip-flop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. Qn+1 = S + R\u2019Qn JK FLIP-FLOP JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has two inputs J & K and two outputs Qn and Qn+1, present and next state respectively, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set & Complement of present state based on the input conditions, when positive transition of clock signal is applied. Qn+1 = J(Qn)\u2019 + K\u2019(Qn) D FLIP-FLOP D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with an enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. This circuit has single input D and two outputs Qn and Qn+1. This flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. D flip-flop always holds the information, which is available on data input, D of earlier positive transition of clock signal. Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal. Qn+1 = D T FLIP-FLOP T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input \u2018T\u2019 to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has single input T and two outputs Qn and Qn+1. The operation of the T flip-flop is the same as that of the JK flip-flop. Here, we considered the inputs of JK flip-flop as J = T and K = T in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, we eliminated the other two combinations of J & K, for which those two values complement each other in a T flip-flop. Qn+1 = T\u2019Q(n) + (Q(n))\u2019T = T XOR Q(n) MULTIPLEXERS 2-1 MUX It selects binary information from one of many input lines and directs the information to a single output line. The selection of a particular input line is controlled by a set of input variables, called selection inputs. there are 2^n input lines and n selection inputs whose bit combinations determine which input is selected. , if the select input S = 0, the output of the multiplexer takes on the values of I 0 , and, if input S = 1, the output of the multiplexer takes on the values of I 1 . Thus, S selects either input I 0 or input I 1 to appear at output Y. We can see that the equation for the 2\u2013to\u20131-line multiplexer output Y is Y = S\u2019I0 + SI1 4-1 MUX The function Y depends on four inputs I 0 , I 1 , I 2 , and I 3 and two select inputs S1 and S0 . By placing the values of I 0 through I 3 in the Y column. Since there are six variables, and only S1 and S0 are fixed, this single row represents 16 rows of the corresponding full truth table. From the table, we can write the equation for Y as Y = S1\u2019S0\u2019 I0 + S1\u2019S0 I1 + S1S0\u2019I2 + S1S0 I3 S1 S2 Y 0 0 I0 0 1 I1 1 0 I2 1 1 I3 DEMULTIPLEXERS 1:2 DEMUX A 1-to-2 demultiplexer consists of one input line, two output lines and one select line. The signal on the select line helps to switch the input to one of the two outputs. When the select input is LOW, then the input will be passed to Y0 and if the select input is HIGH, then the input will be passed to Y1 Y0 = S\u2019 D Y1 = S D PARITY GENERATOR Many systems use a parity bit as a means for bit error detection. Any group of bits contains either an even or an odd number of 1s. A parity bit is attached to a group of bits to make the total number of 1s in a group always even or always odd. An even parity bit makes the total number of 1s even, and an odd parity bit makes the total odd. A parity bit provides for the detection of a single bit error (or any odd number of errors, which is very unlikely) but cannot check for two errors in one group. For instance, let\u2019s assume that we wish to transmit the BCD code 0101. (Parity can be used with any number of bits; we are using four for illustration.) The total code transmitted, including the even parity bit, is Now let\u2019s assume that an error occurs in the third bit from the left (the 1 becomes a 0) When this code is received, the parity check circuitry determines that there is only a single 1 (odd number), when there should be an even number of 1s. Because an even number of 1s does not appear in the code when it is received, an error is indicated. CODE CONVERTER BCD to Binary Code converter The binary numbers representing the weights of the BCD bits are summed to produce the total binary number. The binary equivalent of each BCD bit is a binary number representing the weight of that bit within the total BCD number. Binary to Gray Conversion between binary code and Gray code is sometimes useful. The following rules explain how to convert from a binary number to a Gray code word: 1. The most significant bit (left-most) in the Gray code is the same as the corresponding MSB in the binary number. 2. Going from left to right, add each adjacent pair of binary code bits to get the next Gray code bit. Discard carries Gray to Binary To convert from Gray code to binary, use a similar method; however, there are some differences. The following rules apply: The most significant bit (left-most) in the binary code is the same as the corresponding bit in the Gray code. Add each binary code bit generated to the Gray code bit in the next adjacent position. Discard carries. COMPARATORS The exclusive-NOR gate can be used as a basic comparator because its output is a 0 if the two input bits are not equal and a 1 if the input bits are equal. The basic comparator can be expanded to any number of bits. The AND gate sets the condition that all corresponding bits of the two numbers must be equal if the two numbers themselves are equal. To determine an inequality of binary numbers A and B, you first examine the highest order bit in each number. The following conditions are possible: 1. If A3 = 1 and B3 = 0, number A is greater than number B. 2. If A3 = 0 and B3 = 1, number A is less than number B. 3. If A3 = B3, then you must examine the next lower bit position for an inequality. These three operations are valid for each bit position in the numbers. The general procedure used in a comparator is to check for an inequality in a bit position, starting with the highest-order bits (MSBs). When such an inequality is found, the relationship of the two numbers is established, and any other inequalities in lower-order bit positions must be ignored because it is possible for an opposite indication to occur; the highest-order indication must take precedence. Registers A register is a group of flip\u2010flops, each one of which shares a common clock and is capable of storing one bit of information. An n \u2010bit register consists of a group of n flip\u2010flops capable of storing n bits of binary information. In addition to the flip\u2010flops, a register may have combinational gates that perform certain data\u2010processing tasks. Four\u2010bit register The common clock input triggers all flip\u2010flops on the positive edge of each pulse, and the binary data available at the four inputs are transferred into the register. The value of (I3 , I2 , I1 , I0) immediately before the clock edge determines the value of (A3 , A2 , A1 , A0) after the clock edge. The four outputs can be sampled at any time to obtain the binary information stored in the register. The input Clear_b goes to the active\u2010low R (reset) input of all four flip\u2010flops. When this input goes to 0, all flip\u2010flops are reset asynchronously. The Clear_b input is useful for clearing the register to all 0\u2019s prior to its clocked operation. The R inputs must be maintained at logic 1 (i.e., de-asserted) during normal clocked operation. Note that, depending on the flip\u2010flop, either Clear, Clear_b, reset, or reset_b can be used to indicate the transfer of the register to an all 0\u2019s state. Four bit register with parallel load Gi = Ai AND Bi A four\u2010bit data\u2010storage register with a load control input that is directed through gates and into the D inputs of the flip\u2010flops. The additional gates implement a two\u2010channel mux whose output drives the input to the register with either the data bus or the output of the register. The load input to the register determines the action to be taken with each clock pulse. SHIFT REGISTERS SERIAL IN/SERIAL OUT REGISTERS The serial in/serial out shift register accepts data serially\u2014that is, one bit at a time on a single line. It produces the stored information on its output also in serial form . Serial In/Parallel Out Shift Registers Data bits are entered serially (least-significant bit first) into a serial in/parallel out shift register in the same manner as in serial in/serial out registers. The difference is the way in which the data bits are taken out of the register; in the parallel output register, the output of each stage is available. Once the data is stored, each bit appears on its respective output line, and all bits are available simultaneously, rather than on a bit-by-bit basis as with the serial output. Parallel In/Serial Out Shift Registers For a register with parallel data inputs, the bits are entered simultaneously into their respective stages on parallel lines rather than on a bit-by-bit basis on one line as with serial data inputs. Parallel In/Parallel Out Shift Registers Parallel entry and parallel output of data have been discussed. The parallel in/parallel out register employs both methods. Immediately following the simultaneous entry of all data bits, the bits appear on the parallel outputs. COUNTERS A register that goes through a prescribed sequence of states upon the application of input pulses is called a counter. The input pulses may be clock pulses, or they may originate from some external source and may occur at a fixed interval of time or at random. The sequence of states may follow the binary number sequence or any other sequence of states. BINARY RIPPLE COUNTER A binary ripple counter consists of a series connection of complementing flip\u2010flops, with the output of each flip\u2010flop connected to the C input of the next higher order flip\u2010flop. The flip\u2010flop holding the least significant bit receives the incoming count pulses. A complementing flip\u2010flop can be obtained from a JK flip\u2010flop with the J and K inputs tied together or from a T flip\u2010flop. A third possibility is to use a D flip\u2010flop with the complement output connected to the D input.The output of each flip\u2010flop is connected to the C input of the next flip\u2010flop in sequence. The flip\u2010flop holding the least significant bit receives the incoming count pulses. The bubble in front of the dynamic indicator symbol next to C indicates that the flip\u2010flops respond to the negative\u2010edge transition of the input. The negative transition occurs when the output of the previous flip\u2010flop to which C is connected goes from 1 to 0. BCD RIPPLE COUNTER A decimal counter follows a sequence of 10 states and returns to 0 after the count of 9. Such a counter must have at least four flip\u2010flops to represent each decimal digit, since a decimal digit is represented by a binary code with at least four bits. The sequence of states in a decimal counter is dictated by the binary code used to represent a decimal digit. The four outputs are designated by the letter symbol Q, with a numeric subscript equal to the binary weight of the corresponding bit in the BCD code. Note that the output of Q1 is applied to the C inputs of both Q2 and Q8 and the output of Q2 is applied to the C input of Q4. The J and K inputs are connected either to a permanent 1 signal or to outputs of other flip\u2010flops. 4 BIT SYNCHRONOUS BINARY COUNTER The flip\u2010flop in the least significant position is complemented with every pulse. A flip\u2010flop in any other position is complemented when all the bits in the lower significant positions are equal to 1 . Synchronous binary counters have a regular pattern and can be constructed with complementing flip\u2010flops and gates. The C inputs of all flip\u2010flops are connected to a common clock. The counter is enabled by Count_enable. If the enable input is 0, all J and K inputs are equal to 0 and the clock does not change the state of the counter. The first stage, A0, has its J and K equal to 1 if the counter is enabled. The other J and K inputs are equal to 1 if all previous least significant stages are equal to 1 and the count is enabled. The chain of AND gates generates the required logic for the J and K inputs in each stage. The counter can be extended to any number of stages, with each stage having an additional flip\u2010flop and an AND gate that gives an output of 1 if all previous flip\u2010flop outputs are 1. Note that the flip\u2010flops trigger on the positive edge of the clock. FOUR BIT UP-DOWN BINARY COUNTER The two operations can be combined in one circuit to form a counter capable of counting either up or down. It has an up control input and a down control input. When the up input is 1, the circuit counts up, since the T inputs receive their signals from the values of the previous normal outputs of the flip\u2010flops. BINARY COUNTER WITH PARALLEL LOAD When equal to 1, the input load control disables the count operation and causes a transfer of data from the four data inputs into the four flip\u2010flops. If both control inputs are 0, clock pulses do not change the state of the register. The carry output becomes a 1 if all the flip\u2010flops are equal to 1 while the count input is enabled. This is the condition for complementing the flip\u2010flop that holds the next significant bit. The carry output is useful for expanding the counter to more than four bits. The speed of the counter is increased when the carry is generated directly from the outputs of all four flip\u2010flops, because the delay to generate the carry bit is reduced. A counter with a parallel load can be used to generate any desired count sequence.the Count control is set to 1 to enable the count through the CLK input. Also, recall that the Load control inhibits the count and that the clear operation is independent of other control inputs. ARITHMETIC LOGIC UNIT (ALU) The ALU, or arithmetic logic unit, is a crucial component of the CPU (central processing unit) in a computer system. It is responsible for carrying out arithmetic and logic operations. Also referred to as the integer unit (IU), it is an integrated circuit found in both CPUs and GPUs. The ALU is the final stage in the processor where calculations are performed. It possesses the capability to handle various tasks related to arithmetic and logic operations, including addition, subtraction, shifting operations, as well as Boolean comparisons such as XOR, OR, AND, and NOT operations. It operates on binary numbers and can execute mathematical and bitwise operations. The ALU consists of two units: the arithmetic unit (AU) and the logic unit (LU). By utilizing operands and codes, the ALU determines which operations to perform based on the input data provided. Once the ALU completes processing the input, the resulting information is sent to the computer's memory. Here are the main functions of an ALU: Arithmetic Operations : The ALU performs various arithmetic operations on binary numbers, such as addition, subtraction, multiplication, and division. It uses binary addition and subtraction circuits to handle these operations efficiently. Logical Operations : The ALU executes logical operations on binary data, including AND, OR, XOR (exclusive OR), and NOT. These operations manipulate individual bits or binary values to determine logical relationships and produce logical results. Comparison Operations : The ALU performs comparison operations to determine the relationship between two binary values. It can compare if two values are equal, not equal, greater than, less than, greater than or equal to, or less than or equal to each other. The result of these comparisons is typically represented by setting specific flags or registers in the CPU. Bitwise Operations : The ALU carries out bitwise operations, which manipulate individual bits in binary numbers. These operations include shifting the bits left or right, rotating bits, and masking operations. Bitwise operations are commonly used in tasks such as data manipulation, encryption, and signal processing. Conditional Operations : The ALU supports conditional operations, enabling the CPU to execute different instructions based on certain conditions. For example, it can perform conditional branching, where the CPU jumps to a specific instruction address based on the result of a comparison operation. Data Movement : The ALU may also handle data movement operations within the CPU. This involves transferring data between registers, memory, and other CPU components. ENCODER An encoder is a digital circuit that performs the inverse operation of a decoder. An encoder has 2n (or fewer) input lines and n output lines. PRIORITY ENCODER A priority encoder is an encoder circuit that includes the priority function. The operation of the priority encoder is such that if two or more inputs are equal to 1 at the same time, the input having the highest priority will take precedence. In addition to the two outputs x and y , the circuit has a third output designated by V ; this is a valid bit indicator that is set to 1 when one or more inputs are equal to 1. If all inputs are 0, there is no valid input and V is equal to 0. The other two outputs are not inspected when V equals 0 and are specified as don\u2019t-care conditions. x = D2+ D3 y = D3 + D1 D 2 V = D0 + D1 + D2 + D3 DECODER A decoder is a combinational circuit that converts binary information from n input lines to a maximum of 2n unique output lines.The decoders presented here are called n -to- m -line decoders, where m \u2026 2^n. 3-8 LINE DECODER The three inputs are decoded into eight outputs, each representing one of the minterms of the three input variables. The three inverters provide the complement of the inputs, and each one of the eight AND gates generates one of the minterms. 2-4 LINE DECODER WITH ENABLE INPUT The circuit operates with complemented outputs and a complement enable input. The decoder is enabled when E is equal to 0 (i.e., active-low enable). As indicated by the truth table, only one output can be equal to 0 at any given time; all other outputs are equal to 1. The output whose value is equal to 0 represents the minterm selected by inputs A and B . The circuit is disabled when E is equal to 1, regardless of the values of the other two inputs. When the circuit is disabled, none of the outputs are equal to 0 and none of the minterms are selected. HOW TO MAKE A VERILOG PROGRAM Create a New Project in your own version of Quartus Prime. Select an appropriate directory for your Verilog project files and create an empty project file template. Use the 10M50DAF484C7G Board from the MAX 10 Family. Set ModelSim as your Simulation Tool (ModelSim must be installed prior) and finish the initialization of the project. Click on the file icon in the top left corner and create a new Verilog HDL file. When you wish to save your program, simply use Ctrl+S or click the Save icon in the top left corner. Before running your program, you must first set a testbench for it. Do this by going into the Assignments menu and clicking Settings. Change the NativeLink Setting to Compile Test Bench and select the Test Bench file for your program. Create a new Test Bench if you are creating one for a new program that has not been made before. Name your Test Bench appropriately (usually just the name of the test bench file) and add it to the list of Test Benches. After setting your testbench, you can now run and compile your program by clicking on the third play button. You will be able to view your circuit design and how it is structured, and simulate results using the test bench by going to the Tools menu. BIBLIOGRAPHY Digital Design, 5th Edition by M Morris Mano and Michael Ciletti Digital Fundamentals by Floyd and Jain electronicshub.org/demultiplexerdemux tutorialspoint.com/digital_circuits/digital_circuits_flip_flops tutorialspoint.com/digital_circuits/digital_circuits_demultiplexers","title":"Intro"},{"location":"Intro/#introduction","text":"","title":"INTRODUCTION"},{"location":"Intro/#table-of-contents","text":"Topic Page Introduction 1 Verilog Syntax 2 Basic Logic Gates 3 Binary Adders and Subtractors 4 Latches 5 Flip Flops 6 Multiplexers 7 Demultiplexers 8 Parity Generator 9 Code converter 10 Comparators 11 Registers 12 Counters 13 Arithmetic Logic Unit 14 Encoders 15 Decoders 16 How ro make a verilog program 17 Bibliography 18 --- Verilog is a Hardware Description Language (HDL) . They resemble programming languages specifically oriented to describe hardware structures and their behavior. This language describes an interconnection of components. Such a structural description, a netlist, can be used as input to logic simulation just as a schematic is used. A typical procedure is used in employing an HDL description as simulation input. The steps in the procedure are analysis, elaboration, and initialization, followed by the simulation. Analysis checks the description for violations of the syntax and semantic rules for the HDL and produces an intermediate representation of the design. Elaboration traverses the design hierarchy represented by the description; in this process, the design hierarchy is flattened to an interconnection of modules described only by their behaviors. The result of the analysis and elaboration performed by the compiler is a simulation model of the original HDL description. This model is then passed to the simulator for execution. Initialization sets all of the variables in the simulation model to specified or default values. Simulation executes the simulation model in either batch or interactive mode with inputs specified by the user. The testbench is a description that includes the design to be tested, typically referred to as the Device Under Test (DUT). The testbench describes a collection of hardware and software functions that apply inputs to the DUT and analyze the outputs for correctness. Verilog supports a design at many levels of abstraction. The primary three kinds of abstraction in Verilog are - Behavioral level - Register-transfer level - Gate level","title":"Table of Contents"},{"location":"Intro/#behavioral","text":"This is the highest level of abstraction provided by Verilog HDL. It describes the circuit using procedural statements (the \"always\" block, case, and if statements). At the behavioral level, the circuit is described using an algorithm consisting of a set of instructions executed one after the other sequentially.","title":"Behavioral:"},{"location":"Intro/#data-flow","text":"This is the second highest level of abstraction. It specifies the circuit as a combination of operations and data transfer between the registers. In this approach, the 'assign' statement is used. An assign statement is a continuous statement where any signal changes on the right-hand side will update the output signal. Changes in the inputs are continuously monitored. Any synthesizable code is called RTL code. Gate-Level: This is the lowest level of abstraction. Here, the circuit is described by logical links and their timing properties. The module is implemented in terms of logic gates and interconnections between these gates. It resembles a schematic drawing with components connected with signals.","title":"Data-Flow:"},{"location":"Intro/#functional-differences","text":"","title":"Functional Differences"},{"location":"Intro/#behavioral-level","text":"","title":"Behavioral Level"},{"location":"Intro/#pros","text":"Easy to write and understand, especially for complex algorithms and high-level functionality. Portability: the same behavioral code can be synthesized into different hardware architectures. Enables early verification, allowing designers to test system functionality before committing to a particular hardware architecture.","title":"Pros"},{"location":"Intro/#cons","text":"Less control over the hardware implementation details. Can be less efficient in terms of area, power, and performance than lower levels of abstraction. More difficult to optimize for timing and power.","title":"Cons"},{"location":"Intro/#register-transfer-level-rtl","text":"","title":"Register Transfer Level (RTL)"},{"location":"Intro/#pros_1","text":"Offers greater control over the hardware implementation details. Can be optimized for timing, power, and area, allowing for more efficient designs. Can be used for both simulation and synthesis. Cons More difficult to write and understand than the behavioral level. Can be less portable than the behavioral level, since the same code may not synthesize correctly across different architectures. Can be more difficult to verify than the behavioral level, since the design is more complex.","title":"Pros"},{"location":"Intro/#gate-level","text":"","title":"Gate Level"},{"location":"Intro/#pros_2","text":"Provides the most detailed view of the hardware implementation. Highly optimized for area, power, and performance. Ideal for final verification of the design. Cons Very difficult to write and understand. Not portable: The code is specific to a particular hardware architecture. Verification can be very time-consuming and difficult, especially for complex designs.","title":"Pros"},{"location":"Intro/#verilog-syntax","text":"","title":"VERILOG SYNTAX"},{"location":"Intro/#code","text":"module half_adder(output s, c, input a, b); assign s = a ^ b; assign c = a & b; endmodule module is always terminated by endmodule . Always specify output first and then input.","title":"CODE:"},{"location":"Intro/#testbench","text":"module half_adder_test; reg in1, in2; wire out1, out2; half_adder a1(out1,out2 ,in1, in2); reg [2:0]count; initial begin for(count=0; count<4; count = count+1) begin {in1, in2} = count[1:0]; #20; end end endmodule reg : store input values wire : store output values begin end is used to specify a block of code.","title":"TESTBENCH:"},{"location":"Intro/#basic-logic-gates","text":"Logic gates are basic building blocks of digital electronics circuits that perform logical operations on one or more binary inputs and produce a binary output. In other words, a logic gate is an electronic device that operates on logical signals (digital signals) to perform a Boolean function. There are several types of logic gates, including: AND gate: It has two or more input signals and produces a HIGH output only if all inputs are HIGH. The AND gate symbol is the dot or multiplication symbol. OR gate: It has two or more input signals and produces a HIGH output if at least one input is HIGH. The OR gate symbol is the plus symbol. NOT gate (Inverter): It has one input signal and produces the complement of the input signal at its output. The NOT gate symbol is a triangle with a circle at the output. NAND gate: It is a combination of an AND gate and a NOT gate. It produces a LOW output only if all inputs are HIGH. The NAND gate symbol is an AND gate with a small circle at its output. NOR gate: It is a combination of an OR gate and a NOT gate. It produces a HIGH output only if all inputs are LOW. The NOR gate symbol is an OR gate with a small circle at its output. XOR gate: It has two input signals and produces a HIGH output if the two inputs are different (i.e., one input is HIGH and the other is LOW). The XOR gate symbol is the addition symbol with a circle around it. XNOR gate: It is a combination of an XOR gate and a NOT gate. It produces a HIGH output if the two inputs are the same (i.e., both inputs are HIGH or both inputs are LOW). The XNOR gate symbol is an XOR gate with a small circle at its output.","title":"BASIC LOGIC GATES"},{"location":"Intro/#binary-adders-and-subtractors","text":"","title":"Binary Adders and Subtractors"},{"location":"Intro/#half-adder","text":"A half-adder is an arithmetic circuit that generates the sum of two binary digits. The circuit has two inputs and two outputs. The input variables are the augend and addend bits to be added, and the output variables produce the sum and carry. The Boolean functions for the two outputs, easily obtained from the truth table, are S = XY + XY = X \u2295 Y C = XY x y C S 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0","title":"HALF ADDER"},{"location":"Intro/#full-adder","text":"A full adder is a combinational circuit that forms the arithmetic sum of three input bits. Two input variables, denoted by X and Y, represent the two significant bits to be added. The third input, Z, represents the carry from the previous lower significant position. The simplified sum-of-product functions for the two outputs are : S = XYZ + XYZ + XY Z + XYZ C = XY + XZ + YZ S = (X \u2295 Y) \u2295 Z C = XY + Z(X \u2295 Y)","title":"FULL ADDER"},{"location":"Intro/#ripple-carry-adder","text":"A parallel binary adder is a digital circuit that produces the arithmetic sum of two binary numbers using only combinational logic. The parallel adder uses n full adders in parallel, with all input bits applied simultaneously to produce the sum. The full adders are connected in cascade, with the carry output from one full adder connected to the carry input of the next full adder. Since a 1 carry may appear near the least significant bit of the adder and yet propagate through many full adders to the most significant bit, just as a wave ripples outward from a pebble dropped in a pond, the parallel adder is referred to as a ripple carry adder.","title":"RIPPLE CARRY ADDER"},{"location":"Intro/#carry-look-ahead-adder","text":"Define two new binary variables |Pi = Ai XOR Bi| |---| Gi = Ai AND Bi the output sum and carry can respectively be expressed as Si = Pi XOR Ci Ci+1 = Gi + (Pi AND Ci) Each sum output requires two exclusive-OR gates. The output of the first exclusive-OR gate generates the Pi variable, and the AND gate generates the Gi variable. The carries are propagated through the carry lookahead generator and applied as inputs to the second exclusive-OR gate. All output carries are generated after a delay through two levels of gates. Thus, outputs S1 through S3 have equal propagation delay times.","title":"CARRY LOOK AHEAD ADDER"},{"location":"Intro/#half-subtractor","text":"A half subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) and produces two output bits: the difference (D) and the borrow (B). The half subtractor is called \"half\" because it can only subtract two single-bit binary numbers, unlike a full subtractor that can subtract two multi-bit binary numbers. D= A XOR B B\u2019 = Abar AND B","title":"HALF SUBTRACTOR"},{"location":"Intro/#full-subtractor","text":"A full subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) along with a borrow (Bin) and produces two output bits: the difference (D) and the borrow (Bout). The full subtractor is an extension of the half subtractor, which can only subtract two single-bit binary numbers. D = A XOR B XOR Bin B\u2019 = Abar AND B OR ((A XOR B)bar)Bin","title":"FULL SUBTRACTOR"},{"location":"Intro/#binary-adder-and-subtractor","text":"M-N where M-minuend and N is subtrahend When performing a subtraction we complement the subtrahend N, and when performing an addition we do not complement N. The 2s complement can be obtained by taking the 1s complement and adding 1 to the least significant bit. The 1s complement can be implemented easily with inverter circuits, and we can add 1 to the sum by making the input carry of the parallel adder equal to 1. The input carry C0 must be equal to 1. The operation that is performed becomes A plus the 1s complement of B plus 1. This is equal to A plus the 2s complement of B. For unsigned numbers, it gives A - B if A >= B or the 2s complement of B - A if A <img B","title":"BINARY ADDER AND SUBTRACTOR"},{"location":"Intro/#latches","text":"","title":"LATCHES"},{"location":"Intro/#sr-latch","text":"The SR latch is a circuit constructed from two cross- coupled NOR gates. The latch has two inputs, labeled S for set and R for reset, and two useful states. When output Q = 1 and Q = 0, the latch is said to be in the set state. When Q = 0 and Q = 1, it is in the reset state. Outputs Q and Q are normally the complements of each other. When both inputs are equal to 1 at the same time, an undefined state with both outputs equal to 0 occurs.","title":"SR LATCH"},{"location":"Intro/#sr-latch_1","text":"The SR latch with two cross- coupled NAND gates. It operates with both inputs normally at 1, unless the state of the latch has to be changed. The application of a 0 to the S input causes output Q to go to 1, putting the latch in the set state. When the S input goes back to 1, the circuit remains in the set state. With both inputs at 1, the state of the latch is changed by placing a 0 on the R input. This causes the circuit to go to the reset state and stay there, even after both inputs return to 1. The condition that is undefined for this NAND latch is when both inputs are equal to 0 at the same time, an input combination that should be avoided. When the NAND latch requires a 0 signal to change its state, it is referred to as an SR latch.","title":"S\u0305R\u0305 LATCH"},{"location":"Intro/#sr-latch-with-control-input","text":"It consists of the basic NAND latch and two additional NAND gates. The control input C acts as an enable signal for the other two inputs. The output of the NAND gates stays at the logic- 1 level as long as the control input remains at 0. When the control input goes to 1, information from the S and R inputs is allowed to affect the S R latch. The set state is reached with S = 1, R = 0, and C = 1. To change to the reset state, the inputs must be S = 0, R = 1, and C = 1. In either case, when C returns to 0, the circuit remains in its current state. Control input C = 0 disables the circuit so that the state of the output does not change, regardless of the values of S and R. Moreover, when C = 1 and both the S and R inputs are equal to 0, the state of the circuit does not change.An undefined state occurs when all three inputs are equal to 1. This condition places 0s on both inputs of the basic S R latch, giving an undefined state.","title":"SR LATCH WITH CONTROL INPUT"},{"location":"Intro/#d-latch","text":"One way to eliminate the undesirable undefined state in the SR latch is to ensure that inputs S and R are never equal to 1 at the same time. This is done in the D latch, shown in Figure 4-8. This latch has only two inputs: D (data) and C (control). The complement of the D input goes directly to the S input, and D is applied to the R input. As long as the control input is 0, the S R latch has both inputs at the 1 level, and the circuit cannot change state regardless of the value of D. The D input is sampled when C = 1. If D is 1, the Q output goes to 1, placing the circuit in the set state. If D is 0, output Q goes to 0, placing the circuit in the reset state. The D latch receives its designation from its ability to hold data in its internal storage. The binary information present at the data input of the D latch is transferred to the Q output when the control input is enabled (1). The output follows changes in the data input, as long as the control input is enabled. When the control input is disabled (0), the binary information that was present at the data input at the time the transition in C occurred is retained at the Q output until the control input C is enabled again.","title":"D LATCH"},{"location":"Intro/#flip-flops","text":"There are basically 4 types of flip-flops: 1. SR Flip-Flop 2. JK Flip-Flop 3. D Flip-Flop 4. T Flip-Flop","title":"FLIP FLOPS"},{"location":"Intro/#sr-flip-flop","text":"SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with an enable signal. The circuit diagram of SR flip-flop is shown in the following figure.This circuit has two inputs S & R and two outputs QN and Qn+1, present and next state respectively. The operation of the SR flip-flop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. Qn+1 = S + R\u2019Qn","title":"SR FLIP-FLOP"},{"location":"Intro/#jk-flip-flop","text":"JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has two inputs J & K and two outputs Qn and Qn+1, present and next state respectively, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set & Complement of present state based on the input conditions, when positive transition of clock signal is applied. Qn+1 = J(Qn)\u2019 + K\u2019(Qn)","title":"JK FLIP-FLOP"},{"location":"Intro/#d-flip-flop","text":"D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with an enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. This circuit has single input D and two outputs Qn and Qn+1. This flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. D flip-flop always holds the information, which is available on data input, D of earlier positive transition of clock signal. Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal. Qn+1 = D","title":"D FLIP-FLOP"},{"location":"Intro/#t-flip-flop","text":"T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input \u2018T\u2019 to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has single input T and two outputs Qn and Qn+1. The operation of the T flip-flop is the same as that of the JK flip-flop. Here, we considered the inputs of JK flip-flop as J = T and K = T in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, we eliminated the other two combinations of J & K, for which those two values complement each other in a T flip-flop. Qn+1 = T\u2019Q(n) + (Q(n))\u2019T = T XOR Q(n)","title":"T FLIP-FLOP"},{"location":"Intro/#multiplexers","text":"","title":"MULTIPLEXERS"},{"location":"Intro/#2-1-mux","text":"It selects binary information from one of many input lines and directs the information to a single output line. The selection of a particular input line is controlled by a set of input variables, called selection inputs. there are 2^n input lines and n selection inputs whose bit combinations determine which input is selected. , if the select input S = 0, the output of the multiplexer takes on the values of I 0 , and, if input S = 1, the output of the multiplexer takes on the values of I 1 . Thus, S selects either input I 0 or input I 1 to appear at output Y. We can see that the equation for the 2\u2013to\u20131-line multiplexer output Y is Y = S\u2019I0 + SI1","title":"2-1 MUX"},{"location":"Intro/#4-1-mux","text":"The function Y depends on four inputs I 0 , I 1 , I 2 , and I 3 and two select inputs S1 and S0 . By placing the values of I 0 through I 3 in the Y column. Since there are six variables, and only S1 and S0 are fixed, this single row represents 16 rows of the corresponding full truth table. From the table, we can write the equation for Y as Y = S1\u2019S0\u2019 I0 + S1\u2019S0 I1 + S1S0\u2019I2 + S1S0 I3 S1 S2 Y 0 0 I0 0 1 I1 1 0 I2 1 1 I3","title":"4-1 MUX"},{"location":"Intro/#demultiplexers","text":"","title":"DEMULTIPLEXERS"},{"location":"Intro/#12-demux","text":"A 1-to-2 demultiplexer consists of one input line, two output lines and one select line. The signal on the select line helps to switch the input to one of the two outputs. When the select input is LOW, then the input will be passed to Y0 and if the select input is HIGH, then the input will be passed to Y1 Y0 = S\u2019 D Y1 = S D","title":"1:2 DEMUX"},{"location":"Intro/#parity-generator","text":"Many systems use a parity bit as a means for bit error detection. Any group of bits contains either an even or an odd number of 1s. A parity bit is attached to a group of bits to make the total number of 1s in a group always even or always odd. An even parity bit makes the total number of 1s even, and an odd parity bit makes the total odd. A parity bit provides for the detection of a single bit error (or any odd number of errors, which is very unlikely) but cannot check for two errors in one group. For instance, let\u2019s assume that we wish to transmit the BCD code 0101. (Parity can be used with any number of bits; we are using four for illustration.) The total code transmitted, including the even parity bit, is Now let\u2019s assume that an error occurs in the third bit from the left (the 1 becomes a 0) When this code is received, the parity check circuitry determines that there is only a single 1 (odd number), when there should be an even number of 1s. Because an even number of 1s does not appear in the code when it is received, an error is indicated.","title":"PARITY GENERATOR"},{"location":"Intro/#code-converter","text":"","title":"CODE CONVERTER"},{"location":"Intro/#bcd-to-binary-code-converter","text":"The binary numbers representing the weights of the BCD bits are summed to produce the total binary number. The binary equivalent of each BCD bit is a binary number representing the weight of that bit within the total BCD number.","title":"BCD to Binary Code converter"},{"location":"Intro/#binary-to-gray","text":"Conversion between binary code and Gray code is sometimes useful. The following rules explain how to convert from a binary number to a Gray code word: 1. The most significant bit (left-most) in the Gray code is the same as the corresponding MSB in the binary number. 2. Going from left to right, add each adjacent pair of binary code bits to get the next Gray code bit. Discard carries","title":"Binary to Gray"},{"location":"Intro/#gray-to-binary","text":"To convert from Gray code to binary, use a similar method; however, there are some differences. The following rules apply: The most significant bit (left-most) in the binary code is the same as the corresponding bit in the Gray code. Add each binary code bit generated to the Gray code bit in the next adjacent position. Discard carries.","title":"Gray to Binary"},{"location":"Intro/#comparators","text":"The exclusive-NOR gate can be used as a basic comparator because its output is a 0 if the two input bits are not equal and a 1 if the input bits are equal. The basic comparator can be expanded to any number of bits. The AND gate sets the condition that all corresponding bits of the two numbers must be equal if the two numbers themselves are equal. To determine an inequality of binary numbers A and B, you first examine the highest order bit in each number. The following conditions are possible: 1. If A3 = 1 and B3 = 0, number A is greater than number B. 2. If A3 = 0 and B3 = 1, number A is less than number B. 3. If A3 = B3, then you must examine the next lower bit position for an inequality. These three operations are valid for each bit position in the numbers. The general procedure used in a comparator is to check for an inequality in a bit position, starting with the highest-order bits (MSBs). When such an inequality is found, the relationship of the two numbers is established, and any other inequalities in lower-order bit positions must be ignored because it is possible for an opposite indication to occur; the highest-order indication must take precedence.","title":"COMPARATORS"},{"location":"Intro/#registers","text":"A register is a group of flip\u2010flops, each one of which shares a common clock and is capable of storing one bit of information. An n \u2010bit register consists of a group of n flip\u2010flops capable of storing n bits of binary information. In addition to the flip\u2010flops, a register may have combinational gates that perform certain data\u2010processing tasks.","title":"Registers"},{"location":"Intro/#fourbit-register","text":"The common clock input triggers all flip\u2010flops on the positive edge of each pulse, and the binary data available at the four inputs are transferred into the register. The value of (I3 , I2 , I1 , I0) immediately before the clock edge determines the value of (A3 , A2 , A1 , A0) after the clock edge. The four outputs can be sampled at any time to obtain the binary information stored in the register. The input Clear_b goes to the active\u2010low R (reset) input of all four flip\u2010flops. When this input goes to 0, all flip\u2010flops are reset asynchronously. The Clear_b input is useful for clearing the register to all 0\u2019s prior to its clocked operation. The R inputs must be maintained at logic 1 (i.e., de-asserted) during normal clocked operation. Note that, depending on the flip\u2010flop, either Clear, Clear_b, reset, or reset_b can be used to indicate the transfer of the register to an all 0\u2019s state.","title":"Four\u2010bit register"},{"location":"Intro/#four-bit-register-with-parallel-loadgi-ai-and-bi","text":"A four\u2010bit data\u2010storage register with a load control input that is directed through gates and into the D inputs of the flip\u2010flops. The additional gates implement a two\u2010channel mux whose output drives the input to the register with either the data bus or the output of the register. The load input to the register determines the action to be taken with each clock pulse.","title":"Four bit register with parallel loadGi = Ai AND Bi"},{"location":"Intro/#shift-registers","text":"","title":"SHIFT REGISTERS"},{"location":"Intro/#serial-inserial-out-registers","text":"The serial in/serial out shift register accepts data serially\u2014that is, one bit at a time on a single line. It produces the stored information on its output also in serial form .","title":"SERIAL IN/SERIAL OUT REGISTERS"},{"location":"Intro/#serial-inparallel-out-shift-registers","text":"Data bits are entered serially (least-significant bit first) into a serial in/parallel out shift register in the same manner as in serial in/serial out registers. The difference is the way in which the data bits are taken out of the register; in the parallel output register, the output of each stage is available. Once the data is stored, each bit appears on its respective output line, and all bits are available simultaneously, rather than on a bit-by-bit basis as with the serial output.","title":"Serial In/Parallel Out Shift Registers"},{"location":"Intro/#parallel-inserial-out-shift-registers","text":"For a register with parallel data inputs, the bits are entered simultaneously into their respective stages on parallel lines rather than on a bit-by-bit basis on one line as with serial data inputs.","title":"Parallel In/Serial Out Shift Registers"},{"location":"Intro/#parallel-inparallel-out-shift-registers","text":"Parallel entry and parallel output of data have been discussed. The parallel in/parallel out register employs both methods. Immediately following the simultaneous entry of all data bits, the bits appear on the parallel outputs.","title":"Parallel In/Parallel Out Shift Registers"},{"location":"Intro/#counters","text":"A register that goes through a prescribed sequence of states upon the application of input pulses is called a counter. The input pulses may be clock pulses, or they may originate from some external source and may occur at a fixed interval of time or at random. The sequence of states may follow the binary number sequence or any other sequence of states.","title":"COUNTERS"},{"location":"Intro/#binary-ripple-counter","text":"A binary ripple counter consists of a series connection of complementing flip\u2010flops, with the output of each flip\u2010flop connected to the C input of the next higher order flip\u2010flop. The flip\u2010flop holding the least significant bit receives the incoming count pulses. A complementing flip\u2010flop can be obtained from a JK flip\u2010flop with the J and K inputs tied together or from a T flip\u2010flop. A third possibility is to use a D flip\u2010flop with the complement output connected to the D input.The output of each flip\u2010flop is connected to the C input of the next flip\u2010flop in sequence. The flip\u2010flop holding the least significant bit receives the incoming count pulses. The bubble in front of the dynamic indicator symbol next to C indicates that the flip\u2010flops respond to the negative\u2010edge transition of the input. The negative transition occurs when the output of the previous flip\u2010flop to which C is connected goes from 1 to 0.","title":"BINARY RIPPLE COUNTER"},{"location":"Intro/#bcd-ripple-counter","text":"A decimal counter follows a sequence of 10 states and returns to 0 after the count of 9. Such a counter must have at least four flip\u2010flops to represent each decimal digit, since a decimal digit is represented by a binary code with at least four bits. The sequence of states in a decimal counter is dictated by the binary code used to represent a decimal digit. The four outputs are designated by the letter symbol Q, with a numeric subscript equal to the binary weight of the corresponding bit in the BCD code. Note that the output of Q1 is applied to the C inputs of both Q2 and Q8 and the output of Q2 is applied to the C input of Q4. The J and K inputs are connected either to a permanent 1 signal or to outputs of other flip\u2010flops.","title":"BCD RIPPLE COUNTER"},{"location":"Intro/#4-bit-synchronous-binary-counter","text":"The flip\u2010flop in the least significant position is complemented with every pulse. A flip\u2010flop in any other position is complemented when all the bits in the lower significant positions are equal to 1 . Synchronous binary counters have a regular pattern and can be constructed with complementing flip\u2010flops and gates. The C inputs of all flip\u2010flops are connected to a common clock. The counter is enabled by Count_enable. If the enable input is 0, all J and K inputs are equal to 0 and the clock does not change the state of the counter. The first stage, A0, has its J and K equal to 1 if the counter is enabled. The other J and K inputs are equal to 1 if all previous least significant stages are equal to 1 and the count is enabled. The chain of AND gates generates the required logic for the J and K inputs in each stage. The counter can be extended to any number of stages, with each stage having an additional flip\u2010flop and an AND gate that gives an output of 1 if all previous flip\u2010flop outputs are 1. Note that the flip\u2010flops trigger on the positive edge of the clock.","title":"4 BIT SYNCHRONOUS BINARY COUNTER"},{"location":"Intro/#four-bit-up-down-binary-counter","text":"The two operations can be combined in one circuit to form a counter capable of counting either up or down. It has an up control input and a down control input. When the up input is 1, the circuit counts up, since the T inputs receive their signals from the values of the previous normal outputs of the flip\u2010flops.","title":"FOUR BIT UP-DOWN BINARY COUNTER"},{"location":"Intro/#binary-counter-with-parallel-load","text":"When equal to 1, the input load control disables the count operation and causes a transfer of data from the four data inputs into the four flip\u2010flops. If both control inputs are 0, clock pulses do not change the state of the register. The carry output becomes a 1 if all the flip\u2010flops are equal to 1 while the count input is enabled. This is the condition for complementing the flip\u2010flop that holds the next significant bit. The carry output is useful for expanding the counter to more than four bits. The speed of the counter is increased when the carry is generated directly from the outputs of all four flip\u2010flops, because the delay to generate the carry bit is reduced. A counter with a parallel load can be used to generate any desired count sequence.the Count control is set to 1 to enable the count through the CLK input. Also, recall that the Load control inhibits the count and that the clear operation is independent of other control inputs.","title":"BINARY COUNTER WITH PARALLEL LOAD"},{"location":"Intro/#arithmetic-logic-unit-alu","text":"The ALU, or arithmetic logic unit, is a crucial component of the CPU (central processing unit) in a computer system. It is responsible for carrying out arithmetic and logic operations. Also referred to as the integer unit (IU), it is an integrated circuit found in both CPUs and GPUs. The ALU is the final stage in the processor where calculations are performed. It possesses the capability to handle various tasks related to arithmetic and logic operations, including addition, subtraction, shifting operations, as well as Boolean comparisons such as XOR, OR, AND, and NOT operations. It operates on binary numbers and can execute mathematical and bitwise operations. The ALU consists of two units: the arithmetic unit (AU) and the logic unit (LU). By utilizing operands and codes, the ALU determines which operations to perform based on the input data provided. Once the ALU completes processing the input, the resulting information is sent to the computer's memory. Here are the main functions of an ALU: Arithmetic Operations : The ALU performs various arithmetic operations on binary numbers, such as addition, subtraction, multiplication, and division. It uses binary addition and subtraction circuits to handle these operations efficiently. Logical Operations : The ALU executes logical operations on binary data, including AND, OR, XOR (exclusive OR), and NOT. These operations manipulate individual bits or binary values to determine logical relationships and produce logical results. Comparison Operations : The ALU performs comparison operations to determine the relationship between two binary values. It can compare if two values are equal, not equal, greater than, less than, greater than or equal to, or less than or equal to each other. The result of these comparisons is typically represented by setting specific flags or registers in the CPU. Bitwise Operations : The ALU carries out bitwise operations, which manipulate individual bits in binary numbers. These operations include shifting the bits left or right, rotating bits, and masking operations. Bitwise operations are commonly used in tasks such as data manipulation, encryption, and signal processing. Conditional Operations : The ALU supports conditional operations, enabling the CPU to execute different instructions based on certain conditions. For example, it can perform conditional branching, where the CPU jumps to a specific instruction address based on the result of a comparison operation. Data Movement : The ALU may also handle data movement operations within the CPU. This involves transferring data between registers, memory, and other CPU components.","title":"ARITHMETIC LOGIC UNIT (ALU)"},{"location":"Intro/#encoder","text":"An encoder is a digital circuit that performs the inverse operation of a decoder. An encoder has 2n (or fewer) input lines and n output lines.","title":"ENCODER"},{"location":"Intro/#priority-encoder","text":"A priority encoder is an encoder circuit that includes the priority function. The operation of the priority encoder is such that if two or more inputs are equal to 1 at the same time, the input having the highest priority will take precedence. In addition to the two outputs x and y , the circuit has a third output designated by V ; this is a valid bit indicator that is set to 1 when one or more inputs are equal to 1. If all inputs are 0, there is no valid input and V is equal to 0. The other two outputs are not inspected when V equals 0 and are specified as don\u2019t-care conditions. x = D2+ D3 y = D3 + D1 D 2 V = D0 + D1 + D2 + D3","title":"PRIORITY ENCODER"},{"location":"Intro/#decoder","text":"A decoder is a combinational circuit that converts binary information from n input lines to a maximum of 2n unique output lines.The decoders presented here are called n -to- m -line decoders, where m \u2026 2^n.","title":"DECODER"},{"location":"Intro/#3-8-line-decoder","text":"The three inputs are decoded into eight outputs, each representing one of the minterms of the three input variables. The three inverters provide the complement of the inputs, and each one of the eight AND gates generates one of the minterms.","title":"3-8 LINE DECODER"},{"location":"Intro/#2-4-line-decoder-with-enable-input","text":"The circuit operates with complemented outputs and a complement enable input. The decoder is enabled when E is equal to 0 (i.e., active-low enable). As indicated by the truth table, only one output can be equal to 0 at any given time; all other outputs are equal to 1. The output whose value is equal to 0 represents the minterm selected by inputs A and B . The circuit is disabled when E is equal to 1, regardless of the values of the other two inputs. When the circuit is disabled, none of the outputs are equal to 0 and none of the minterms are selected.","title":"2-4 LINE DECODER WITH ENABLE INPUT"},{"location":"Intro/#how-to-make-a-verilog-program","text":"","title":"HOW TO MAKE A VERILOG PROGRAM"},{"location":"Intro/#create-a-new-project-in-your-own-version-of-quartus-prime","text":"","title":"Create a New Project in your own version of Quartus Prime."},{"location":"Intro/#select-an-appropriate-directory-for-your-verilog-project-files-and-create-an-empty-project-file-template","text":"","title":"Select an appropriate directory for your Verilog project files and create an empty project file template."},{"location":"Intro/#use-the-10m50daf484c7g-board-from-the-max-10-family","text":"","title":"Use the 10M50DAF484C7G Board from the MAX 10 Family."},{"location":"Intro/#set-modelsim-as-your-simulation-tool-modelsim-must-be-installed-prior-and-finish-the-initialization-of-the-project","text":"","title":"Set ModelSim as your Simulation Tool (ModelSim must be installed prior) and finish the initialization of the project."},{"location":"Intro/#click-on-the-file-icon-in-the-top-left-corner-and-create-a-new-verilog-hdl-file","text":"","title":"Click on the file icon in the top left corner and create a new Verilog HDL file."},{"location":"Intro/#when-you-wish-to-save-your-program-simply-use-ctrls-or-click-the-save-icon-in-the-top-left-corner","text":"","title":"When you wish to save your program, simply use Ctrl+S or click the Save icon in the top left corner."},{"location":"Intro/#before-running-your-program-you-must-first-set-a-testbench-for-it-do-this-by-going-into-the-assignments-menu-and-clicking-settings","text":"","title":"Before running your program, you must first set a testbench for it. Do this by going into the Assignments menu and clicking Settings."},{"location":"Intro/#change-the-nativelink-setting-to-compile-test-bench-and-select-the-test-bench-file-for-your-program","text":"","title":"Change the NativeLink Setting to Compile Test Bench and select the Test Bench file for your program."},{"location":"Intro/#create-a-new-test-bench-if-you-are-creating-one-for-a-new-program-that-has-not-been-made-before","text":"","title":"Create a new Test Bench if you are creating one for a new program that has not been made before."},{"location":"Intro/#name-your-test-bench-appropriately-usually-just-the-name-of-the-test-bench-file-and-add-it-to-the-list-of-test-benches","text":"","title":"Name your Test Bench appropriately (usually just the name of the test bench file) and add it to the list of Test Benches."},{"location":"Intro/#after-setting-your-testbench-you-can-now-run-and-compile-your-program-by-clicking-on-the-third-play-button","text":"","title":"After setting your testbench, you can now run and compile your program by clicking on the third play button."},{"location":"Intro/#you-will-be-able-to-view-your-circuit-design-and-how-it-is-structured-and-simulate-results-using-the-test-bench-by-going-to-the-tools-menu","text":"","title":"You will be able to view your circuit design and how it is structured, and simulate results using the test bench by going to the Tools menu."},{"location":"Intro/#bibliography","text":"Digital Design, 5th Edition by M Morris Mano and Michael Ciletti Digital Fundamentals by Floyd and Jain electronicshub.org/demultiplexerdemux tutorialspoint.com/digital_circuits/digital_circuits_flip_flops tutorialspoint.com/digital_circuits/digital_circuits_demultiplexers","title":"BIBLIOGRAPHY"}]}